[
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x2df1c51e09aecf9cacb7bc98cb1742757f163df7;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1704144000; // Conerted to unix\\n    uint256 public terminationDate = 1735680000;\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0;\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Acme Technologies Corp. (Hereinafter referred to as \"Employer\")\\nAnd John Smith Address: 123 Main Street, Anytown, USA (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Senior Software Engineer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on February 29, 2024, and shall terminate on February 28, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $100,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x2df1c51e09aecf9cacb7bc98cb1742757f163df7. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: ______________\\n"
    },  
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xf977814e90da44bfa03b6295a0616a897441acec;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5416; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1711084800; // March 15, 2024, in UNIX timestamp\\n    uint256 public terminationDate = 1742620800; // March 14, 2025, in UNIX timestamp\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0;\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Tech Innovations Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Emily Johnson Address: 456 Oak Avenue, Springfield, XYZ (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Marketing Specialist. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment undecr this contract shall commence on March 15, 2024, and shall terminate on March 14, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $65,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xf977814e90da44bfa03b6295a0616a897441acec. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer; // InnovateX Solutions Inc. will set this upon deployment\\n    address public employee = 0xf977814e90da44bfa03b6295a0616a897441acec;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6250; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1713033600;\\n    uint256 public terminationDate = 1744569600; \\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0;\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween InnovateX Solutions Inc. (Hereinafter referred to as \"Employer\")\\nAnd Michael Thompson Address: 789 Pine Street, Lakeside, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Financial Analyst. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on April 10, 2024, and shall terminate on April 9, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $75,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xf977814e90da44bfa03b6295a0616a897441acec. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer; // Innovative Solutions Co.'s address to be set upon deployment\\n    address public employee = 0xf977814e90da44bfa03b6295a0616a897441acec; // Sarah Rodriguez's designated wallet address\\n    address private authorizedApp;\\n    uint256 public salary = 4583; // Monthly salary, $55,000 per annum in USDC, assuming $55,000 / 12 months\\n    IERC20 private usdcToken;\\n    uint256 public startDate = 1715539200; // May 5, 2024, in UNIX timestamp\\n    uint256 public terminationDate = 1747075200; // May 4, 2025, in UNIX timestamp\\n    uint256 public lastSalaryPaidDate;\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0;\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Innovative Solutions Co. (Hereinafter referred to as \"Employer\")\\nAnd Sarah Rodriguez Address: 567 Elm Street, Rivertown, XYZ (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Graphic Designer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on May 5, 2024, and shall terminate on May 4, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $55,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xf977814e90da44bfa03b6295a0616a897441acec. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer; // employer's address to be set upon deployment\\n    address public employee = 0xb38e8c17e38363af6ebdcb3dae12e0243582891d;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7083; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1718838000; // unix Thu Jun 20 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1750287600; // unix Thu Jun 19 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween GlobalTech Solutions LLC (Hereinafter referred to as \"Employer\")\\nAnd David Kim Address: 789 Maple Avenue, Cityville, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Sales Manager. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on June 20, 2024, and shall terminate on June 19, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $85,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xb38e8c17e38363af6ebdcb3dae12e0243582891d. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xb38e8c17e38363af6ebdcb3dae12e0243582891d;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1720566000; // unix timsteamp of Wed Jul 10 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1752015600; //unix timsteamp of Wed Jul 09 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween TechGenius Innovations Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Jessica Smith Address: 101 Oak Lane, Sunnyvale, XYZ (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Software Engineer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on July 10, 2024, and shall terminate on July 9, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $90,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xb38e8c17e38363af6ebdcb3dae12e0243582891d. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x7711c90bd0a148f3dd3f0e587742dc152c3e9ddb;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5833; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1723676400; // unix timestamp of Thu Aug 15 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1755126000; // unix timstamp of \tThu Aug 14 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Innovative Solutions Co. (Hereinafter referred to as \"Employer\")\\nAnd Alexandra Johnson Address: 321 Cedar Street, Hilltop, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Human Resources Specialist. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on August 15, 2024, and shall terminate on August 14, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $70,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x7711c90bd0a148f3dd3f0e587742dc152c3e9ddb. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xa656f7d2a93a6f5878aa768f24eb38ec8c827fe2;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6666; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1725490800; // Unix timestamp of Thu Sep 05 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1756940400; // Unix timestamp of Thu Sep 04 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Tech Solutions Innovate Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Daniel Brown Address: 456 Pine Street, Mountainview, XYZ (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Project Manager. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on September 5, 2024, and shall terminate on September 4, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $80,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xa656f7d2a93a6f5878aa768f24eb38ec8c827fe2. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xc6962004f452be9203591991d15f6b388e09e8d0;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7083; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1728514800; // Unix timestamp of Thu Oct 10 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1759964400; // Unix timestamp of Thu Oct 09 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Innovative Solutions Co. (Hereinafter referred to as \"Employer\")\\nAnd Michaela Johnson Address: 789 Willow Avenue, Parkside, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Marketing Manager. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on October 10, 2024, and shall terminate on October 9, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $85,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xc6962004f452be9203591991d15f6b388e09e8d0. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x09400d9db990d5ed3f35d7be61dfaeb900af03c9;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7916; // Monthly salary amount in USDC ($95,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1731628800; // Unix timestamp of Fri Nov 15 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1763078400; // Unix timestamp of \tFri Nov 14 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Tech Solutions Innovate Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Emily Davis Address: 123 Oak Street, Springfield, XYZ (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Software Developer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on November 15, 2024, and shall terminate on November 14, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $95,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x09400d9db990d5ed3f35d7be61dfaeb900af03c9. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xc25cef6061cf5de5eb761b50e4743c1f5d7e5407;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5000; // Monthly salary amount in USDC ($60,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1733011200; // Unix timestamp of Sun Dec 01 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1764460800; // Unix timestamp of Sun Nov 30 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Innovative Solutions Co. (Hereinafter referred to as \"Employer\")\\nAnd Christopher Thompson Address: 456 Maple Street, Hillside, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Sales Representative. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on December 1, 2024, and shall terminate on November 30, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $60,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xc25cef6061cf5de5eb761b50e4743c1f5d7e5407. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xf89d7b9c864f589bbf53a82105107622b35eaa40;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 3750; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1736467200; // Unix timestamp of Fri Jan 10 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1767916800; // Unix timestamp of Fri Jan 09 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n    \\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Innovative Solutions Co. (Hereinafter referred to as \"Employer\")\\nAnd Sophia Garcia Address: 789 Cedar Avenue, Lakeside, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Customer Service Representative. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on January 10, 2025, and shall terminate on January 9, 2026, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $45,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xf89d7b9c864f589bbf53a82105107622b35eaa40. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x62383739d68dd0f844103db8dfb05a7eded5bbe6;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5833; // Monthly salary amount in USDC ($70,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1740009600; // Unix timestmap of Thu Feb 20 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1771459200; // Unix timestamp of Thu Feb 19 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Tech Innovations Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Matthew Wilson Address: 987 Elm Street, Rivertown, XYZ (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Data Analyst. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on February 20, 2025, and shall terminate on February 19, 2026, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $70,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x62383739d68dd0f844103db8dfb05a7eded5bbe6. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x1f7bc4da1a0c2e49d7ef542f74cd46a3fe592cb1;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 4583; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1741132800; // Unix timestamp of Wed Mar 05 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1772582400; // Unix timestamp of Wed Mar 04 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Tech Solutions Innovate Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Olivia Anderson Address: 321 Oak Street, Hilltop, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Marketing Coordinator. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on March 5, 2025, and shall terminate on March 4, 2026, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $55,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x1f7bc4da1a0c2e49d7ef542f74cd46a3fe592cb1. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xae1ec28d6225dce2ff787dcb8ce11cf6d3ae064f;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6250; // Monthly salary amount in USDC ($75,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1744671600; // Unix timestampf of Tue Apr 15 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1776121200; // Unix timestamp of Tue Apr 14 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Innovative Solutions Co. (Hereinafter referred to as \"Employer\")\\nAnd Emma Davis Address: 789 Pine Street, Lakeside, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Financial Analyst. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on April 15, 2025, and shall terminate on April 14, 2026, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $75,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xae1ec28d6225dce2ff787dcb8ce11cf6d3ae064f. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x8bb6cae3f1cada07dd14ba951e02886ea6bba183;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7500; // Monthly salary amount in USDC ($90,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1746054000; // Unix timestamp of Thu May 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1777503600; // Unix timestamp of Thu Apr 30 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Tech Innovations Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Benjamin Martinez Address: 456 Cedar Street, Hilltop, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Software Engineer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on May 1, 2025, and shall terminate on April 30, 2026, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $90,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x8bb6cae3f1cada07dd14ba951e02886ea6bba183. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x724dc807b04555b71ed48a6896b6f41593b8c637;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1746054000; // Unix timestamp of Thu May 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1777503600; // Unix timestamp of Thu Apr 30 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Agreement\\nBetween Tech Innovations Ltd. (Hereinafter referenced as \"Employer\")\\nAnd Benjamin Martinez Address: 456 Cedar Street, Hilltop, ABC (Hereinafter referred to as \"Employee\")\\nRole and Responsibilities The Employer hereby engages the Employee on a full-time basis as a Software Developer. The Employee undertakes to fulfill the tasks and obligations assigned by the Employer diligently and to the utmost of their capabilities.\\nDuration of Engagement This employment agreement shall be effective from May 1, 2025, until April 30, 2026, unless sooner terminated as per the terms laid down herein.\\nCompensation The Employer commits to remunerating the Employee with an annual salary of $90,000 USD, to be disbursed monthly in USDC tokens to the Employee's designated digital wallet address 0x9045ae36f963b7184861bdce205ea8b08913b48c. Payments will be processed no later than the 5th day of each month.\\nPerformance Evaluation The Employee's performance will undergo annual assessment, with the possibility of salary adjustments at the discretion of the Employer, based on performance metrics and accomplishments.\\nTermination Clause This contract may be terminated prematurely by either party upon providing a written notice period of 30 days. In the event of termination, the Employee shall be entitled to receive accrued salary up to the date of termination.\\nConfidentiality Agreement During and after the term of employment, the Employee agrees to maintain strict confidentiality regarding all proprietary information of the Employer.\\nJurisdiction This agreement shall be governed by the laws of the jurisdiction where the Employer's principal place of business is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this agreement as of the last date written below.\\nEmployer's Signature: ___________________ Date: _______________\\nEmployee's Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x724dc807b04555b71ed48a6896b6f41593b8c637;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7500; // Monthly salary amount in USDC ($90,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1746054000; // Unix timestamp of Thu May 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1777503600; // Unix timestamp of Thu Apr 30 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Work Pact\\nBetween Innovative Tech Firm Inc. (Hereinafter denoted as \"Employer\")\\nAnd Samuel Johnson Address: 789 Maple Street, Hillside, ABC (Hereinafter termed as \"Worker\")\\nPosition and Obligations The Employer hereby enlists the Worker on a full-time basis as a Software Developer. The Worker agrees to execute the designated tasks and duties assigned by the Employer with diligence and proficiency.\\nContract Period This employment arrangement shall remain in effect from May 1, 2025, to April 30, 2026, unless terminated earlier in accordance with the terms outlined herein.\\nRemuneration The Employer commits to providing the Worker with an annual salary of $90,000 USD, payable monthly in USDC tokens to the Worker's designated cryptocurrency wallet address 0x724dc807b04555b71ed48a6896b6f41593b8c637. Payment will be disbursed no later than the 5th day of each month.\\nPerformance Evaluation The performance of the Worker will be subject to an annual review, with potential salary adjustments contingent upon the discretion of the Employer and based on established performance metrics.\\nTermination Clause Either party reserves the right to terminate this agreement with a written notice period of 30 days. In the event of termination, the Worker shall be entitled to receive all accrued salary up to the termination date.\\nConfidentiality Commitment Throughout and subsequent to the tenure of employment, the Worker agrees to maintain strict confidentiality regarding all proprietary information belonging to the Employer.\\nLegal Framework This pact shall be governed by the laws of the jurisdiction where the principal office of the Employer is situated.\\nIN WITNESS WHEREOF, the undersigned parties have executed this agreement as of the date mentioned below.\\nEmployer's Signature: ___________________ Date: _______________\\nWorker's Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xb1026b8e7276e7ac75410f1fcbbe21796e8f7526;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6666; // Monthly salary amount in USDC ($80,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1746054000; // Unix timestamp of Thu May 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1777503600; // Unix timestamp of Thu Apr 30 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n    \\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Covenant\\nBetween Innovative Minds Co. (Hereinafter referred to as the \"Employer\")\\nAnd Evelyn Green Address: 123 Pine Street, Sunnyside, XYZ (Hereinafter referred to as the \"Employee\")\\nRole and Commitments The Employer engages the Employee in a full-time capacity as a Creative Design Specialist. The Employee pledges to carry out assigned responsibilities with dedication and creativity, contributing positively to the Employer's objectives.\\nDuration of Collaboration This collaborative venture shall commence on May 1, 2025, and conclude on April 30, 2026, unless terminated prematurely as per the terms herein.\\nCompensation The Employer undertakes to provide the Employee with an annual compensation of $80,000 USD, to be remitted monthly in USDC tokens to the Employee's designated digital wallet address 0xb1026b8e7276e7ac75410f1fcbbe21796e8f7526. Payments will be processed no later than the 5th day of each month.\\nPerformance Appraisal The Employee's performance shall undergo periodic review, with potential salary adjustments at the discretion of the Employer, based on performance evaluations and achievements.\\nTermination Clause This agreement may be terminated by either party with a 30-day written notice. Upon termination, the Employee shall receive accrued salary up to the termination date.\\nConfidentiality Assurance Throughout and after the term of employment, the Employee shall uphold strict confidentiality concerning all proprietary information belonging to the Employer.\\nLegal Parameters This pact shall be governed by the laws of the jurisdiction where the principal office of the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have affixed their signatures as of the date indicated below.\\nEmployer's Signature: ___________________ Date: _______________\\nEmployee's Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x7f1fa204bb700853d36994da19f830b6ad18455c;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5833; // Monthly salary amount in USDC ($70,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1747263600; // Unix timestamp of Thu May 15 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1776121200; // Unix timestamp of Tue Apr 14 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Accord\\nBetween NexGen Innovations Inc. (Hereinafter referred to as the \"Employer\")\\nAnd Isabella Cruz Address: 789 Oak Avenue, Riverside, XYZ (Hereinafter referred to as the \"Employee\")\\nPosition and Responsibilities The Employer appoints the Employee as a Digital Marketing Strategist on a full-time basis. The Employee agrees to undertake all duties assigned by the Employer diligently and effectively.\\nDuration of Engagement This contract shall be effective from May 15, 2025, until April 14, 2026, unless terminated earlier in accordance with the terms herein.\\nCompensation Package The Employer shall compensate the Employee with an annual salary of $70,000 USD, disbursed monthly in USDC tokens to the Employee's specified digital wallet address 0x7f1fa204bb700853d36994da19f830b6ad18455c. Payments will be executed no later than the 5th day of each month.\\nPerformance Assessment The performance of the Employee will be evaluated annually, with the potential for salary adjustments based on performance metrics and achievements.\\nTermination Clause Either party reserves the right to terminate this agreement with a notice period of 30 days. Upon termination, the Employee shall receive all accrued salary up to the date of termination.\\nConfidentiality Agreement The Employee agrees to maintain strict confidentiality regarding all proprietary information of the Employer, both during and after the term of employment.\\nLegal Jurisdiction This contract shall be governed by the laws of the jurisdiction where the principal office of the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this agreement on the date specified below.\\nEmployer's Signature: ___________________ Date: _______________\\nEmployee's Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x6b84b666e241da59f7520262805a07100f720960;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC ($100,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1709164800; // Unix timestamp of Thu Feb 29 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740700800; // Unix timestamp of Fri Feb 28 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Acme Technologies Corp. (Hereinafter referred to as \"Employer\")\\nAnd John Smith Address: 123 Main Street, Anytown, USA (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Senior Software Engineer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on February 29, 2024, and shall terminate on February 28, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $100,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x6b84b666e241da59f7520262805a07100f720960. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: ______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x1ab4973a48dc892cd9971ece8e01dcc7688f8f23;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC (100,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1748732400; // Unix timestamp of Sun Jun 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1780182000; // unix timestamp of Sun May 31 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n        \\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween NextGen Solutions Inc. (Hereinafter referred to as the \"Employer\")\\nAnd Liam Parker Address: 456 Elm Street, Valleyview, ABC (Hereinafter referred to as the \"Employee\")\\nRole and Responsibilities The Employer hereby engages the Employee in the role of Senior Software Developer on a full-time basis. The Employee agrees to fulfill all job responsibilities diligently and effectively.\\nContract Duration This agreement shall commence on June 1, 2025, and expire on May 31, 2026, unless terminated earlier in accordance with the terms herein.\\nCompensation Package The Employer shall provide the Employee with an annual salary of $100,000 USD, to be paid monthly in USDC tokens to the Employee's designated digital wallet address 0x1ab4973a48dc892cd9971ece8e01dcc7688f8f23. Payments will be disbursed no later than the 5th day of each month.\\nPerformance Review The performance of the Employee will be evaluated annually, with potential salary adjustments based on performance appraisals and achievements.\\nTermination Clause Either party may terminate this contract with a notice period of 30 days. Upon termination, the Employee will be entitled to receive all accrued salary up to the termination date.\\nConfidentiality Agreement The Employee shall maintain strict confidentiality regarding all proprietary information of the Employer, both during and after the term of employment.\\nLegal Framework This contract shall be governed by the laws of the jurisdiction where the Employer's principal office is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this agreement on the date specified below.\\nEmployer's Signature: ___________________ Date: _______________\\nEmployee's Signature: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x2d340912aa47e33c90efb078e69e70efe2b34b9b;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC ($100,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1748732400; // Unix timestamp of Sun Jun 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1780182000; // Unix timestamp of Sun May 31 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Talent Pact\\nBetween NextGen Innovations Inc. (Hereinafter referred to as the \"Innovator\")\\nAnd Liam Parker Address: 456 Elm Street, Valleyview, ABC (Hereinafter referred to as the \"Trailblazer\")\\nRole and Responsibilities The Innovator bestows upon the Trailblazer the esteemed position of Senior Software Sorcerer on a full-time voyage. The Trailblazer pledges to wield their digital wand with mastery and passion, conjuring solutions and weaving codes of innovation.\\nContract Voyage Embarking on this odyssey on June 1, 2025, the Trailblazer and Innovator shall traverse the digital seas until May 31, 2026, navigating storms and calms alike, unless the winds of change decree an earlier return to port.\\nCompensation Treasure In exchange for their courageous exploits, the Trailblazer shall receive an annual chest of gold doubloons totaling $100,000 USD, to be deposited monthly in the treasure chest (USDC account) marked by the digital coordinates 0x2d340912aa47e33c90efb078e69e70efe2b34b9b. Plunder shall be divided no later than the 5th day of each moon.\\nPerformance Quest At the turn of each year, the Trailblazer's exploits shall be celebrated in the grand hall, with their treasure chest adjusted accordingly based on the tales spun of their valor and achievements.\\nTermination Decree Should the compass steer the Trailblazer elsewhere or the siren's song beckon them to distant shores, a decree of 30 days' notice shall be issued, granting both parties time to prepare for the parting of ways. With the parting, the Trailblazer shall be awarded their share of plunder up until the eve of departure.\\nConfidentiality Oath The Trailblazer solemnly swears upon their honor to guard the secrets of the realm, keeping all scrolls and incantations of the Innovator's craft under lock and key, even after the voyage has ended.\\nLegal Cartography Let it be known across the seven seas that this pact shall be bound by the laws of the realm where the Innovator's stronghold stands tall, casting its shadow over land and sea alike.\\nIN WITNESS WHEREOF, the Trailblazer and Innovator have affixed their marks upon this scroll on this day, in the year of our digital age.\\nInnovator's Mark: ___________________ Date: _______________\\nTrailblazer's Mark: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xd3443ee1e91af28e5fb858fbd0d72a63ba8046e0;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC ($100,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1748732400; // Unix timestamp of Sun Jun 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1780182000; // Unix timestamp of Sun May 31 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Adventure Contract\\nBetween NextGen Explorations Inc. (Hereinafter referred to as the \"Voyageurs\")\\nAnd Liam Parker Address: 456 Elm Street, Valleyview, ABC (Hereinafter referred to as the \"Adventurer\")\\nRole and Expedition Duties The Voyageurs appoint the Adventurer as Chief Code Crusader, embarking on a full-time quest. The Adventurer vows to conquer digital landscapes, wielding keyboards like swords and debugging bugs like vanquishing dragons.\\nExpedition Duration This epic journey commences on June 1, 2025, and charts its course until May 31, 2026, unless unforeseen perils or treasure troves lead to an early return to the safety of harbor.\\nCompensation Booty For their intrepid feats, the Adventurer shall be rewarded with an annual bounty of $100,000 USD, deposited monthly in the treasure chest (USDC account) marked with the cryptic code 0xd3443ee1e91af28e5fb858fbd0d72a63ba8046e0. Booty shall be divvied no later than the 5th day of each lunar cycle.\\nPerformance Quests At the year's end, tales of the Adventurer's exploits shall be shared around the campfire, with treasure chests adjusted to reflect the glory and spoils of their quests.\\nTermination Farewell Should the call of distant shores or the siren's song beckon, a farewell decree of 30 days shall be issued, allowing both crew and captain time to prepare for the parting of ways. With farewells exchanged, the Adventurer shall be granted their share of treasure up to the eve of departure.\\nConfidentiality Pirate Code The Adventurer pledges allegiance to the Pirate Code, swearing to guard the secrets of the ship, keeping all maps and navigational charts of the Voyageurs' trade routes safe from prying eyes, even after the voyage has come to an end.\\nLegal Cartography Let it be known across the seven seas that this accord shall be bound by the laws of the realm where the Voyageurs' ship sets sail, navigating the choppy waters of commerce and innovation alike.\\nIN WITNESS WHEREOF, the Adventurer and Voyageurs have hoisted their flags upon this scroll on this day, in the year of our digital discoveries.\\nVoyageurs' Flag: ___________________ Date: _______________\\nAdventurer's Flag: ___________________ Date: _______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xd3443ee1e91af28e5fb858fbd0d72a63ba8046e0;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1751324400; // Unix timestamp of Tue Jul 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1782774000; // Ubix timestamp of Tue Jun 30 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Professional Services Agreement\\nParties:\\nThis Professional Services Agreement (\"Agreement\") is entered into between:\\nTech Solutions Innovate Ltd., a corporation organized and existing under the laws of California, with its principal place of business located at 123 Tech Street, Silicon Valley, CA 94010 (hereinafter referred to as the \"Company\"),\\nand\\nJohn Smith, an individual providing services under the laws of California, with a business address at 456 Main Street, San Francisco, CA 94102 (hereinafter referred to as the \"Service Provider\").\\nScope of Work:\\nThe Company hereby engages the Service Provider to provide the following services (\"Services\"):\\nDevelopment and implementation of a custom software solution on a full-time basis\\nMaintenance and support for existing software systems\\nIntegration of third-party APIs for enhanced functionality\\nTerm:\\nThis Agreement shall commence on July 1, 2025, and shall continue in full force and effect until the completion of the Services, estimated to be on June 30, 2026, unless terminated earlier as provided herein.\\nCompensation:\\nIn consideration for the Services performed by the Service Provider, the Company agrees to pay the Service Provider a monthly fee of $8,000 USD according to the following terms:\\nPayment of $8,000 USD shall be made on the 15th day of each month.\\nPayment to be transferred to employees USDC address: 0xd3443ee1e91af28e5fb858fbd0d72a63ba8046e0\\nOwnership of Work Product:\\nAny work product, including but not limited to reports, documents, or deliverables, produced by the Service Provider in the course of providing the Services shall belong exclusively to the Company.\\nConfidentiality:\\nThe Service Provider agrees to keep confidential all information received from the Company during the term of this Agreement and thereafter, except as required by law.\\nTermination:\\nEither party may terminate this Agreement upon written notice to the other party if there is a material breach of any provision of this Agreement, which breach is not cured within 30 days of written notice.\\nGoverning Law and Jurisdiction:\\nThis Agreement shall be governed by and construed in accordance with the laws of California. Any disputes arising out of or in connection with this Agreement shall be subject to the exclusive jurisdiction of the courts of California.\\nGeneral Provisions:\\nEntire Agreement: This Agreement constitutes the entire agreement between the parties concerning the subject matter hereof and supersedes all prior and contemporaneous agreements and understandings, whether written or oral.\\nAmendment: This Agreement may only be amended in writing and signed by both parties.\\nSeverability: If any provision of this Agreement is held to be invalid or unenforceable, the remaining provisions shall continue to be valid and enforceable.\\nWaiver: The failure of either party to enforce any provision of this Agreement shall not constitute a waiver of such provision or any other provision.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTech Solutions Innovate Ltd.\\nBy: Jane Doe\\nTitle: CEO\\nDate: July 1, 2025\\nJohn Smith\\nBy: John Smith\\nTitle: Service Provider\\nDate: July 1, 2025\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x816f722424b49cf1275cc86da9840fbd5a6167e9;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1755212400; // Unix timestamp of Fri Aug 15 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1786662000; // Unix timestamp of Fri Aug 14 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n    \\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Professional Services Agreement\\nParties:\\nThis Professional Services Agreement (\"Agreement\") is entered into between:\\nInnovative Solutions Corp., a corporation organized and existing under the laws of New York, with its principal place of business located at 789 Innovation Avenue, New York, NY 10001 (hereinafter referred to as the \"Company\"),\\nand\\nEmily Johnson, an individual providing services under the laws of New York, with a business address at 123 Main Street, Brooklyn, NY 11201 (hereinafter referred to as the \"Service Provider\").\\nScope of Work:\\nThe Company hereby engages the Service Provider to provide the following services (\"Services\"):\\nDesign and implementation of a marketing strategy for product launch on a full-time basis.\\nManagement of social media campaigns and advertisements\\nAnalysis of market trends and competitor research\\nTerm:\\nThis Agreement shall commence on August 15, 2025, and shall continue in full force and effect until the completion of the Services, estimated to be on August 14, 2026, unless terminated earlier as provided herein.\\nCompensation:\\nIn consideration for the Services performed by the Service Provider, the Company agrees to pay the Service Provider a monthly fee of $6,000 USD according to the following terms:\\nPayment of $3,000 USD shall be made on the 1st day of each month.\\nPayment of $3,000 USD shall be made on the 15th day of each month.\\nPayment to be transferred to employees USDC address:\\n0x816f722424b49cf1275cc86da9840fbd5a6167e9\\nOwnership of Work Product:\\nAny work product, including but not limited to reports, documents, or deliverables, produced by the Service Provider in the course of providing the Services shall belong exclusively to the Company.\\nConfidentiality:\\nThe Service Provider agrees to keep confidential all information received from the Company during the term of this Agreement and thereafter, except as required by law.\\nTermination:\\nEither party may terminate this Agreement upon written notice to the other party if there is a material breach of any provision of this Agreement, which breach is not cured within 30 days of written notice.\\nGoverning Law and Jurisdiction:\\nThis Agreement shall be governed by and construed in accordance with the laws of New York. Any disputes arising out of or in connection with this Agreement shall be subject to the exclusive jurisdiction of the courts of New York.\\nGeneral Provisions:\\nEntire Agreement: This Agreement constitutes the entire agreement between the parties concerning the subject matter hereof and supersedes all prior and contemporaneous agreements and understandings, whether written or oral.\\nAmendment: This Agreement may only be amended in writing and signed by both parties.\\nSeverability: If any provision of this Agreement is held to be invalid or unenforceable, the remaining provisions shall continue to be valid and enforceable.\\nWaiver: The failure of either party to enforce any provision of this Agreement shall not constitute a waiver of such provision or any other provision.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovative Solutions Corp.\\nBy: John Doe\\nTitle: CEO\\nDate: August 15, 2025\\nEmily Johnson\\nBy: Emily Johnson\\nTitle: Service Provider\\nDate: August 15, 2025\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x9c4ec768c28520b50860ea7a15bd7213a9ff58bf;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 150*8*5*4.4; // Monthly salary amount in USDC (150 USD per Hour * 8 working hours a day * 5 days a week * 4.4 weeks in a month)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1756681200; // Unix timestamp of Mon Sep 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n\\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Consulting Services Agreement\\nParties:\\nThis Consulting Services Agreement (\"Agreement\") is made and entered into between:\\nTech Visionaries Inc., a corporation organized and existing under the laws of Delaware, with its principal place of business located at 456 Tech Avenue, Techland, DE 12345 (hereinafter referred to as the \"Company\"),\\nand\\nMichael Williams, an individual providing consulting services under the laws of Delaware, with a business address at 789 Consultant Street, Consultville, DE 67890 (hereinafter referred to as the \"Consultant\").\\nScope of Services:\\nThe Company engages the Consultant to provide consulting services related to strategic planning, business development, and market analysis (hereinafter referred to as the \"Services\") on a full-time basis. The specific details of the Services shall be outlined in a separate Statement of Work (SOW) to be agreed upon by both parties.\\nTerm:\\nThis Agreement shall commence on September 1, 2025, and shall continue until the completion of the Services as specified in the SOW, unless terminated earlier as provided herein.\\nCompensation:\\nIn consideration for the Services performed by the Consultant, the Company agrees to pay the Consultant a fee of $150 per hour. Payment shall be made on a monthly basis, with invoices submitted by the Consultant and payment due within 30 days of receipt of the invoice. Payment to be made to employees USDC address: 0x9c4ec768c28520b50860ea7a15bd7213a9ff58bf\\nOwnership of Work Product:\\nAny work product, including but not limited to reports, presentations, or recommendations, produced by the Consultant in the course of providing the Services shall be the exclusive property of the Company.\\nConfidentiality:\\nThe Consultant agrees to maintain the confidentiality of all proprietary and confidential information of the Company and shall not disclose such information to any third party without the prior written consent of the Company.\\nTermination:\\nEither party may terminate this Agreement upon written notice to the other party if there is a material breach of any provision of this Agreement, which breach is not cured within 30 days of written notice.\\nGoverning Law and Jurisdiction:\\nThis Agreement shall be governed by and construed in accordance with the laws of Delaware. Any disputes arising out of or in connection with this Agreement shall be subject to the exclusive jurisdiction of the courts of Delaware.\\nGeneral Provisions:\\nEntire Agreement: This Agreement constitutes the entire agreement between the parties concerning the subject matter hereof and supersedes all prior and contemporaneous agreements and understandings, whether written or oral.\\nAmendment: This Agreement may only be amended in writing and signed by both parties.\\nSeverability: If any provision of this Agreement is held to be invalid or unenforceable, the remaining provisions shall continue to be valid and enforceable.\\nWaiver: The failure of either party to enforce any provision of this Agreement shall not constitute a waiver of such provision or any other provision.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTech Visionaries Inc.\\nBy: Sarah Johnson\\nTitle: Chief Executive Officer\\nDate: September 1, 2025\\nMichael Williams\\nBy: Michael Williams\\nTitle: Consultant\\nDate: September 1, 2025\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x463f5d63e5a5edb8615b0e485a090a18aba08578;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 9166; // Monthly salary amount in USDC ($110,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1743375600; // Unix timestamp of Mon Mar 31 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n\\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nInnoTech Solutions Inc., a corporation organized and existing under the laws of New York, with its principal place of business located at 789 Innovation Avenue, New York, NY 10001 (hereinafter referred to as the \"Company\"),\\nand\\nEmily Watson, an individual employed under the laws of New York, with a residential address at 456 Elm Street, Brooklyn, NY 11201 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Software Engineer on a full-time basis. The Employee agrees to perform the duties and responsibilities associated with this role diligently and professionally.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on March 15, 2025, and shall continue until terminated by either party in accordance with the terms herein.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $110,000 USD per annum. Salary payments will be made bi-weekly, with the first payment occurring on March 31, 2025. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be mad to employees crypto wallet in USDC with the following address: 0x463f5d63e5a5edb8615b0e485a090a18aba08578\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, retirement plans, and any other benefits provided to full-time employees.\\nPerformance Review:\\nThe Employee's performance will be subject to regular review by the Company's management team. Performance evaluations may result in salary adjustments, promotions, or other recognition of exemplary performance.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon giving written notice to the other party. The Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain the confidentiality of all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of New York.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnoTech Solutions Inc.\\nBy: John Smith\\nName: John Smith\\nTitle: CEO\\nDate: March 15, 2025\\nEmily Watson\\nBy: Emily Watson\\nName: Emily Watson\\nDate: March 15, 2025\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x3a3F1d48968f2F8Bb9c09633c905Ba29D55D78e5;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10000; // Monthly salary amount in USDC ($120,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1751324400; // Unix timestamp of Tue Jul 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1814310000; // Unix timestamp of Wed Jun 30 2027 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nTechSolve Innovations Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 789 Tech Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nDaniel Parker, an individual employed under the laws of California, with a residential address at 123 Oak Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Software Engineer on a full-time basis. The Employee agrees to develop software solutions and contribute to the technological advancement of the company.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on July 1, 2025, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on June 30, 2027.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $120,000 USD per annum. Salary payments will be made on a monthly basis, with the first payment occurring on July 31, 2025. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x3dd1d15b3c78d6acfd75a254e857cbe5b9ff0af2.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan.\\nPerformance Review:\\nThe Employee's performance will be reviewed annually by the Company's management team. Salary adjustments and bonuses may be awarded based on performance metrics and achievement of company goals.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTechSolve Innovations Inc.\\nBy: Emily Carter\\nName: Emily Carter\\nTitle: CEO\\nDate: July 1, 2025\\nDaniel Parker\\nBy: Daniel Parker\\nName: Daniel Parker\\nDate: July 1, 2025\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x562d29b54d2c57f8620c920415c4dceadd6de2d2;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 11666; // Monthly salary amount in USDC ($140,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1755212400; // Unix timestamp of Fri Aug 15 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1849820400; // Unix timestamp of Mon Aug 14 2028 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n\\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nBright Minds Technologies LLC, a limited liability company organized and existing under the laws of Delaware, with its principal place of business located at 123 Tech Park Avenue, Wilmington, DE 19801 (hereinafter referred to as the \"Company\"),\\nand\\nEmma Roberts, an individual employed under the laws of Delaware, with a residential address at 456 Maple Street, Dover, DE 19901 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Product Manager on a full-time basis. The Employee agrees to oversee product development, manage project timelines, and collaborate with cross-functional teams to bring innovative products to market.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on August 15, 2025, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be three years, terminating on August 14, 2028.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $140,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on August 30, 2025. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x562d29b54d2c57f8620c920415c4dceadd6de2d2.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including comprehensive health insurance, dental coverage, and a 401(k) retirement savings plan with company matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for outstanding contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 60 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of Delaware.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nBright Minds Technologies LLC\\nBy: Robert Johnson\\nName: Robert Johnson\\nTitle: Chief Executive Officer\\nDate: August 15, 2025\\nEmma Roberts\\nBy: Emma Roberts\\nName: Emma Roberts\\nDate: August 15, 2025\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x9047927b42e6e531d1d6f6dc29a9ca626dc57f88;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 9166; // Monthly salary amount in USDC ($110,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = \t1756681200; // Unix timestamp of Mon Sep 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1819666800; // Unix timestamp of Tue Aug 31 2027 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n\\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nInnovateTech Solutions Inc., a corporation organized and existing under the laws of New York, with its principal place of business located at 456 Innovation Avenue, New York, NY 10001 (hereinafter referred to as the \"Company\"),\\nand\\nJames Anderson, an individual employed under the laws of New York, with a residential address at 789 Oak Street, Brooklyn, NY 11201 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Marketing Manager on a full-time basis. The Employee agrees to develop marketing strategies, oversee campaigns, and collaborate with internal and external stakeholders to drive brand awareness and revenue growth.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on September 1, 2025, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on August 31, 2027.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $110,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on September 15, 2025. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x9047927b42e6e531d1d6f6dc29a9ca626dc57f88.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional performance.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of New York.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovateTech Solutions Inc.\\nBy: Samantha White\\nName: Samantha White\\nTitle: Chief Executive Officer\\nDate: September 1, 2025\\nJames Anderson\\nBy: James Anderson\\nName: James Anderson\\nDate: September 1, 2025\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x9b64203878f24eb0cdf55c8c6fa7d08ba0cf77e5;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10833; // Monthly salary amount in USDC ($130,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1759273200; // Unix timestamp of Wed Oct 01 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1853881200; // Unix timestamp of Sat Sep 30 2028 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n\\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nTechPioneer Solutions Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 789 Pioneer Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nSophia Martinez, an individual employed under the laws of California, with a residential address at 456 Elm Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior UX Designer on a full-time basis. The Employee agrees to conceptualize and design user experiences, conduct user research, and collaborate with cross-functional teams to create intuitive and engaging digital products.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on October 1, 2025, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be three years, terminating on September 30, 2028.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $130,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on October 15, 2025. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x9b64203878f24eb0cdf55c8c6fa7d08ba0cf77e5.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including comprehensive health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for outstanding contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTechPioneer Solutions Inc.\\nBy: David Thompson\\nName: David Thompson\\nTitle: Chief Executive Officer\\nDate: October 1, 2025\\nSophia Martinez\\nBy: Sophia Martinez\\nName: Sophia Martinez\\nDate: October 1, 2025\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xc887b673632dee97c4ebb861a2660cc883d39059;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 12500; // Monthly salary amount in USDC ($150,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1761955200; // Unix timestamp of Sat Nov 01 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1824937200; // Unix timestamp of Sun Oct 31 2027 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nInnovative Dynamics Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 123 Innovation Street, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nAlexander Johnson, an individual employed under the laws of California, with a residential address at 456 Elm Avenue, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Data Scientist on a full-time basis. The Employee agrees to analyze data, develop algorithms, and contribute to data-driven decision-making processes to drive business growth and innovation.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on November 1, 2025, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on October 31, 2027.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $150,000 USD per annum. Salary payments will be made on a monthly basis, with the first payment occurring on November 30, 2025. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0xc887b673632dee97c4ebb861a2660cc883d39059.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including comprehensive health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional performance.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovative Dynamics Inc.\\nBy: Emily Johnson\\nName: Emily Johnson\\nTitle: CEO\\nDate: November 1, 2025\\nAlexander Johnson\\nBy: Alexander Johnson\\nName: Alexander Johnson\\nDate: November 1, 2025\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x1aBcdeF0123456789AbCdeF0123456789AbCdeF0;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10000; // Monthly salary amount in USDC ($120,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1764547200; // Unix timestamp of Mon Dec 01 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1859155200; // Unix timestamp of Thu Nov 30 2028 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nTechGenius Innovations Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 789 Innovation Boulevard, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nIsabella Thompson, an individual employed under the laws of California, with a residential address at 456 Maple Lane, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Software Developer on a full-time basis. The Employee agrees to design, develop, and maintain software solutions to meet the needs of the Company and its clients.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on December 1, 2025, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be three years, terminating on November 30, 2028.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $120,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on December 15, 2025. The Employee's salary will be subject to applicable withholdings and deductions.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for outstanding contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nUSDC Wallet Address:\\nThe Company agrees to pay the Employee's salary in USDC tokens to the following wallet address: 0x1aBcdeF0123456789AbCdeF0123456789AbCdeF0\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTechGenius Innovations Inc.\\nBy: Ethan Cooper\\nName: Ethan Cooper\\nTitle: Chief Executive Officer\\nDate: December 1, 2025\\nIsabella Thompson\\nBy: Isabella Thompson\\nName: Isabella Thompson\\nDate: December 1, 2025\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x8932aa60a7b5efefa8ec3ee899fd238d029d10c6;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC ($100,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1767225600; // Unix timestamp of Thu Jan 01 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1830211200; // Unix timestamp of Fri Dec 31 2027 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nDataSprint Technologies Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 123 Data Drive, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nMichael Davis, an individual employed under the laws of California, with a residential address at 456 Oak Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Data Analyst on a full-time basis. The Employee agrees to analyze data, generate insights, and contribute to strategic decision-making processes.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on January 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on December 31, 2027.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $100,000 USD per annum. Salary payments will be made on a monthly basis, with the first payment occurring on January 31, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x8932aa60a7b5efefa8ec3ee899fd238d029d10c6.\\n\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for outstanding contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nDataSprint Technologies Inc.\\nBy: Rachel Adams\\nName: Rachel Adams\\nTitle: Chief Executive Officer\\nDate: January 1, 2026\\nMichael Davis\\nBy: Michael Davis\\nName: Michael Davis\\nDate: January 1, 2026\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xfcfc2f2e9a18488e87f0fc88c95037a8506e8750;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10833; // Monthly salary amount in USDC ($130,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1769904000; // Unix timestamp of Sun Feb 01 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1864512000; // Unix timestamp of Wed Jan 31 2029 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nTechNexus Innovations Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 789 Nexus Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nOlivia Garcia, an individual employed under the laws of California, with a residential address at 456 Maple Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Software Engineer on a full-time basis. The Employee agrees to design, develop, and maintain software applications to meet the Company's business objectives.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on February 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be three years, terminating on January 31, 2029.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $130,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on February 15, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0xfcfc2f2e9a18488e87f0fc88c95037a8506e8750.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional performance.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTechNexus Innovations Inc.\\nBy: Ethan Miller\\nName: Ethan Miller\\nTitle: Chief Executive Officer\\nDate: February 1, 2026\\nOlivia Garcia\\nBy: Olivia Garcia\\nName: Olivia Garcia\\nDate: February 1, 2026\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x0ccb4faa6f1f1b30911619f1184082ab4e25813c;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 11666; // Monthly salary amount in USDC ($140,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1772323200; // Unix timestamp \\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nQuantumTech Solutions Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 123 Quantum Street, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nDavid Wilson, an individual employed under the laws of California, with a residential address at 456 Oak Avenue, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior AI Engineer on a full-time basis. The Employee agrees to develop and implement artificial intelligence algorithms, conduct research, and contribute to innovative projects.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on March 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on February 28, 2028.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $140,000 USD per annum. Salary payments will be made on a monthly basis, with the first payment occurring on March 31, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x0ccb4faa6f1f1b30911619f1184082ab4e25813c.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nUSDC Wallet Address:\\nThe Company agrees to pay the Employee's salary in USDC tokens to the following wallet address: 0x5AbCDeF0123456789AbCDeF0123456789AbCDeF0\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nQuantumTech Solutions Inc.\\nBy: Sarah Adams\\nName: Sarah Adams\\nTitle: CEO\\nDate: March 1, 2026\\nDavid Wilson\\nBy: David Wilson\\nName: David Wilson\\nDate: March 1, 2026\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xfae2ae0a9f87fd35b5b0e24b47bac796a7eefea1;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10416; // Monthly salary amount in USDC ($125,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1774998000; // Unix timestamp of Wed Apr 01 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1869606000; // Unix timestamp of Sat Mar 31 2029 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nInnovative Solutions Group Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 789 Innovation Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nSophie Adams, an individual employed under the laws of California, with a residential address at 456 Elm Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Product Manager on a full-time basis. The Employee agrees to oversee product development, market analysis, and strategic planning to drive business growth and success.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on April 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be three years, terminating on March 31, 2029. Payment to be made to employees USDC address: 0xfae2ae0a9f87fd35b5b0e24b47bac796a7eefea1.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $125,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on April 15, 2026. The Employee's salary will be subject to applicable withholdings and deductions.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for outstanding contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovative Solutions Group Inc.\\nBy: Ryan Johnson\\nName: Ryan Johnson\\nTitle: CEO\\nDate: April 1, 2026\\nSophie Adams\\nBy: Sophie Adams\\nName: Sophie Adams\\nDate: April 1, 2026\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x69f1216cb2905bf0852f74624d5fa7b5fc4da710;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 11250; // Monthly salary amount in USDC ($130,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1777590000; // Unix timestamp of\tFri May 01 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1840662000; // Unix timestamp of Sun Apr 30 2028 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nTechWave Innovations Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 123 Tech Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nDaniel Parker, an individual employed under the laws of California, with a residential address at 456 Maple Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Data Scientist on a full-time basis. The Employee agrees to analyze data, develop machine learning models, and provide insights to support strategic decision-making.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on May 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on April 30, 2028.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $135,000 USD per annum. Salary payments will be made on a monthly basis, with the first payment occurring on May 31, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x69f1216cb2905bf0852f74624d5fa7b5fc4da710\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for outstanding contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTechWave Innovations Inc.\\nBy: Emily Watson\\nName: Emily Watson\\nTitle: CEO\\nDate: May 1, 2026\\nDaniel Parker\\nBy: Daniel Parker\\nName: Daniel Parker\\nDate: May 1, 2026\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x20fa1822a87d4e7a3ccf20f86e716ef3772ecff1;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10833; // Monthly salary amount in USDC ($130,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1780268400; // Unix timestamp of\tMon Jun 01 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1874876400; // Unix timestamp ofThu May 31 2029 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nInnovaTech Solutions Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 789 Innovation Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nEmily Rodriguez, an individual employed under the laws of California, with a residential address at 456 Elm Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Software Engineer on a full-time basis. The Employee agrees to design, develop, and maintain software applications, ensuring high performance and reliability.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on June 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be three years, terminating on May 31, 2029.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $130,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on June 15, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x20fa1822a87d4e7a3ccf20f86e716ef3772ecff1\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovaTech Solutions Inc.\\nBy: Adam Johnson\\nName: Adam Johnson\\nTitle: CEO\\nDate: June 1, 2026\\nEmily Rodriguez\\nBy: Emily Rodriguez\\nName: Emily Rodriguez\\nDate: June 1, 2026\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x7a5df878e195d09f1c0bbba702cfdf0ac9d0a835;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1709164800; // Unix timestamp of\tThu Feb 29 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740700800; // Unix timestamp of Fri Feb 28 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Acme Technologies Corp. (Hereinafter referred to as \"Employer\")\\nAnd John Smith Address: 123 Main Street, Anytown, USA (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Senior Software Engineer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on February 29, 2024, and shall terminate on February 28, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $100,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x7a5df878e195d09f1c0bbba702cfdf0ac9d0a835. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: ______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x6853ea96ff216fab11d2d930ce3c508556a4bdc4;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10000; // Monthly salary amount in USDC ($120,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1782860400; // Unix timestamp of Wed Jul 01 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1845932400; // Unix timestamp of Fri Jun 30 2028 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nInnovativeTech Solutions Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 789 Innovation Street, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nJacob Thompson, an individual employed under the laws of California, with a residential address at 456 Maple Avenue, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Data Analyst on a full-time basis. The Employee agrees to analyze data, generate insights, and develop reports to support decision-making processes.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on July 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on June 30, 2028.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $120,000 USD per annum. Salary payments will be made on a monthly basis, with the first payment occurring on July 31, 2026. The Employee's salary will be subject to applicable withholdings and deductions.\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching. Payment to be made to employees USDC address: 0x6853ea96ff216fab11d2d930ce3c508556a4bdc4.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovativeTech Solutions Inc.\\nBy: Jennifer Lee\\nName: Jennifer Lee\\nTitle: CEO\\nDate: July 1, 2026\\nJacob Thompson\\nBy: Jacob Thompson\\nName: Jacob Thompson\\nDate: July 1, 2026\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xd6216fc19db775df9774a6e33526131da7d19a2c;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 9166; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1785538800; // Unix timestamp of Sat Aug 01 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1880146800; // Unix timestamp of Tue Jul 31 2029 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nFull-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nTechSavvy Solutions LLC, a limited liability company organized and existing under the laws of California, with its principal place of business located at 789 Tech Drive, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nEmma Reynolds, an individual employed under the laws of California, with a residential address at 456 Oak Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Marketing Manager on a full-time basis. The Employee agrees to develop and execute marketing strategies, oversee campaigns, and analyze market trends to drive business growth.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on August 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be three years, terminating on July 31, 2029.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $110,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on August 15, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0xd6216fc19db775df9774a6e33526131da7d19a2c\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTechSavvy Solutions LLC\\nBy: Kevin White\\nName: Kevin White\\nTitle: CEO\\nDate: August 1, 2026\\nEmma Reynolds\\nBy: Emma Reynolds\\nName: Emma Reynolds\\nDate: August 1, 2026\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x3a2d44e354f2d88ef6da7a5a4646fd70182a7f55;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 12083; // Monthly salary amount in USDC ($145,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1788217200; // Unix timestamp of\tTue Sep 01 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1851289200; // Unix timestamp of Thu Aug 31 2028 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nFull-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nDigital Dynamics Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 123 Digital Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nChristopher Nguyen, an individual employed under the laws of California, with a residential address at 456 Maple Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Software Developer on a full-time basis. The Employee agrees to design, develop, and maintain software applications, ensuring high-quality code and timely delivery of projects.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on September 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on August 31, 2028.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $145,000 USD per annum. Salary payments will be made on a monthly basis, with the first payment occurring on September 30, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0x3a2d44e354f2d88ef6da7a5a4646fd70182a7f55\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for outstanding contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nDigital Dynamics Inc.\\nBy: Olivia Smith\\nName: Olivia Smith\\nTitle: CEO\\nDate: September 1, 2026\\nChristopher Nguyen\\nBy: Christopher Nguyen\\nName: Christopher Nguyen\\nDate: September 1, 2026\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xea8a734db4c7ea50c32b5db8a0cb811707e8ace3;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10000; // Monthly salary amount in USDC ($120,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1790809200; // Unix timestamp of Thu Oct 01 2026 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1885417200; // Unix timestamp of Sun Sep 30 2029 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    /// Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Apologies for the oversight. Let me generate a new set of random data for you:\\nFull-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nInnovateTech Solutions LLC, a limited liability company organized and existing under the laws of California, with its principal place of business located at 789 Innovation Street, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nLiam Johnson, an individual employed under the laws of California, with a residential address at 456 Elm Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Data Analyst on a full-time basis. The Employee agrees to analyze data, generate insights, and develop reports to support decision-making processes.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on October 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be three years, terminating on September 30, 2029.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $120,000 USD per annum. Salary payments will be made on a bi-weekly basis, with the first payment occurring on October 15, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0xea8a734db4c7ea50c32b5db8a0cb811707e8ace3\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovateTech Solutions LLC\\nBy: Sophia Martinez\\nName: Sophia Martinez\\nTitle: CEO\\nDate: October 1, 2026\\nLiam Johnson\\nBy: Liam Johnson\\nName: Liam Johnson\\nDate: October 1, 2026\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xa17afcab059f3c6751f5b64347b5a503c3291868;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10833; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1793491200; // Unix timestamp of Sun Nov 01 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1856563200; // Unix timestamp of Tue Oct 31 2028 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Full-Time Employment Agreement\\nParties:\\nThis Full-Time Employment Agreement (\"Agreement\") is entered into between:\\nInnovative Solutions Inc., a corporation organized and existing under the laws of California, with its principal place of business located at 789 Innovation Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nSophia Lee, an individual employed under the laws of California, with a residential address at 456 Elm Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nPosition and Duties:\\nThe Company hereby employs the Employee in the position of Senior Marketing Manager on a full-time basis. The Employee agrees to develop and implement marketing strategies, oversee campaigns, and analyze market trends to drive business growth.\\nTerm of Employment:\\nThe employment under this Agreement shall commence on November 1, 2026, and shall continue until terminated by either party in accordance with the terms herein. The initial term of employment shall be two years, terminating on October 31, 2028.\\nSalary:\\nThe Company agrees to pay the Employee a salary of $130,000 USD per annum. Salary payments will be made on a monthly basis, with the first payment occurring on November 30, 2026. The Employee's salary will be subject to applicable withholdings and deductions. Payment to be made to employees USDC address: 0xa17afcab059f3c6751f5b64347b5a503c3291868\\n\\nBenefits:\\nIn addition to the salary, the Employee shall be entitled to participate in the Company's employee benefits program, including health insurance, dental coverage, and a 401(k) retirement savings plan with employer matching.\\nPerformance Review:\\nThe Employee's performance will be reviewed semi-annually by the Company's management team. Performance evaluations may result in salary increases, bonuses, or other forms of recognition for exceptional contributions.\\nTermination:\\nEither party may terminate this Agreement at any time, with or without cause, upon providing written notice to the other party. The notice period for termination shall be 30 days. Upon termination, the Employee shall be entitled to receive any accrued but unpaid salary up to the termination date.\\nConfidentiality:\\nThe Employee agrees to maintain strict confidentiality regarding all proprietary information of the Company, both during and after the term of employment.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement:\\nThis Agreement constitutes the entire understanding between the parties concerning the subject matter hereof and supersedes all prior agreements and understandings, whether written or oral.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovative Solutions Inc.\\nBy: Michael Adams\\nName: Michael Adams\\nTitle: CEO\\nDate: November 1, 2026\\nSophia Lee\\nBy: Sophia Lee\\nName: Sophia Lee\\nDate: November 1, 2026\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xec090cf6dd891d2d014bea6edada6e05e025d93d;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 10833; // Monthly salary amount in USDC ($130,000 per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1710460800; // Unix timestamp of Fri Mar 15 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1773446400; // Unix timestamp of Sat Mar 14 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Agreement\\nThis Employment Agreement (\"Agreement\") is made and entered into on February 27, 2024, between:\\nInnovative Solutions Inc., a corporation organized and existing under the laws of California, having its principal place of business at 789 Innovation Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nAlexandra Johnson, residing at 456 Elm Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\n1. Engagement:\\nThe Company hereby engages the Employee, and the Employee agrees to be engaged by the Company, as a Senior Software Engineer on a full-time basis.\\n2. Commencement:\\nThe employment under this Agreement shall commence on March 15, 2024.\\n3. Term:\\nThe initial term of employment shall be 2 years from the Start Date, terminating on March 14, 2026.\\n4. Duties:\\nThe Employee shall perform such duties as may be reasonably assigned to them by the Company, including but not limited to software development, code reviews, and system maintenance.\\n5. Compensation:\\nIn consideration for the services rendered by the Employee, the Company shall pay the Employee a salary of $130,000 per annum, payable monthly. Payment to be made to employees USDC address: 0xec090cf6dd891d2d014bea6edada6e05e025d93d\\n\\n6. Benefits:\\nThe Employee shall be entitled to participate in the Company's employee benefits program, subject to the terms and conditions of such program.\\n7. Termination:\\nThis Agreement may be terminated by either party with a 30-day written notice.\\n8. Confidentiality:\\nDuring the term of employment and thereafter, the Employee shall not disclose any confidential information of the Company.\\n10. Governing Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of California.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nInnovative Solutions Inc.\\nBy: Emily Watson\\nName: Emily Watson\\nTitle: CEO\\nDate: February 27, 2024\\nAlexandra Johnson\\nBy: Alexandra Johnson\\nName: Alexandra Johnson\\nDate: February 27, 2024\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x3e0199792ce69dc29a0a36146bfa68bd7c8d6633;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 9166; // Monthly salary amount in USDC ($110,000 per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1711926000; // Unix timestamp ofMon Apr 01 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1806447600; // Unix timestamp of Wed Mar 31 2027 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Agreement\\nThis Employment Agreement (\"Agreement\") is made and entered into on February 27, 2024, between:\\nTechGenius Enterprises LLC, a limited liability company organized and existing under the laws of California, having its principal place of business at 456 Tech Street, San Francisco, CA 94105 (hereinafter referred to as the \"Company\"),\\nand\\nDaniel Ramirez, residing at 789 Maple Avenue, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\n1. Engagement:\\nThe Company hereby engages the Employee, and the Employee agrees to be engaged by the Company, as a Data Analyst on a full-time basis.\\n2. Commencement:\\nThe employment under this Agreement shall commence on April 1, 2024.\\n3. Term:\\nThe initial term of employment shall be 3 years from the Start Date, terminating on March 31, 2027.\\n4. Duties:\\nThe Employee shall perform such duties as may be reasonably assigned to them by the Company, including but not limited to data analysis, report generation, and database management.\\n5. Compensation:\\nIn consideration for the services rendered by the Employee, the Company shall pay the Employee a salary of $110,000 per annum, payable bi-weekly. Payment to be made to employees USDC address: 0x3e0199792ce69dc29a0a36146bfa68bd7c8d6633\\n6. Benefits:\\nThe Employee shall be entitled to participate in the Company's employee benefits program, subject to the terms and conditions of such program.\\n7. Termination:\\nThis Agreement may be terminated by either party with a 30-day written notice.\\n8. Governing Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of California.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTechGenius Enterprises LLC\\nBy: Samantha Roberts\\nName: Samantha Roberts\\nTitle: CEO\\nDate: February 27, 2024\\nDaniel Ramirez\\nBy: Daniel Ramirez\\nName: Daniel Ramirez\\nDate: February 27, 2024\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xba12222222228d8ba445958a75a0704d566bf2c8;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1711926000; // Unix timestamp of Mon Apr 01 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Agreement\\nThis Employment Agreement (\"Agreement\") is entered into on February 27, 2024, between:\\nTechPros Innovations Inc., a corporation organized and existing under the laws of California, with its principal place of business at 789 Innovation Avenue, San Francisco, CA 94105 (hereinafter referred to as the \"Employer\"),\\nand\\nJessica Parker, an individual residing at 456 Maple Street, Los Angeles, CA 90001 (hereinafter referred to as the \"Employee\").\\nEngagement:\\nThe Employer hereby engages the Employee as a Senior Software Developer on a full-time basis, effective from the Start Date.\\nPosition:\\nThe Employee shall assume the responsibilities of designing, developing, and maintaining software applications, ensuring high-quality code and timely delivery of projects.\\nTerm:\\nThis Agreement shall commence on April 1, 2024, and shall remain in effect until terminated by either party in accordance with the terms herein.\\nSalary:\\nIn consideration of the services provided, the Employer shall pay the Employee a monthly salary of $8,500, subject to applicable taxes and withholdings. Payment to be made to employees USDC address: 0xba12222222228d8ba445958a75a0704d566bf2c8\\nBenefits:\\nThe Employee shall be eligible for participation in the Employer's benefits program, including health insurance and retirement plans, following the completion of the probationary period.\\nProbationary Period:\\nThe Employee's performance will be subject to a probationary period of 90 days, during which either party may terminate this Agreement with immediate effect.\\nConfidentiality:\\nThe Employee agrees to maintain the confidentiality of all proprietary information belonging to the Employer, both during and after the termination of this Agreement.\\nTermination:\\nThis Agreement may be terminated by either party upon providing 30 days' written notice to the other party.\\nGoverning Law:\\nThis Agreement shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the parties hereto have executed this Agreement as of the date first above written.\\nTechPros Innovations Inc.\\nBy: John Doe\\nName: John Doe\\nTitle: CEO\\nDate: February 27, 2024\\nJessica Parker\\nBy: Jessica Parker\\nName: Jessica Parker\\nDate: February 27, 2024\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x1344a36a1b56144c3bc62e7757377d288fde0369;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1724713200; // Unix timestamp of Tue Aug 27 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is entered into between BlueSky Enterprises Inc., located at 123 Main Street, Anytown, USA, referred to as the \"Company,\" and John Doe, residing at 456 Oak Avenue, Anytown, USA, referred to as the \"Employee,\" on February 27, 2024.\\n1. Job Title and Responsibilities: 1.1 The Company hereby employs the Employee as a Senior Marketing Analyst. The Employee shall perform all duties and responsibilities related to this position as assigned by the Company.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and continue until August 27, 2024, unless terminated earlier in accordance with this Contract.\\n3. Compensation: 3.1 In consideration of the services provided by the Employee, the Company shall pay the Employee a salary of $5,000 per month, to be deposited to the Employee's USDC wallet address: 0x1344a36a1b56144c3bc62e7757377d288fde0369.\\n4. Termination: 4.1 Either party may terminate this Contract with written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Miscellaneous: 5.1 This Contract constitutes the entire agreement between the parties concerning employment matters and supersedes any prior agreements or understandings, whether written or oral. 5.2 This Contract shall be governed by and construed in accordance with the laws of the State of California. 5.3 Any modifications to this Contract must be made in writing and signed by both parties.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nBlueSky Enterprises Inc.\\nBy: [Authorized Signatory]\\nJohn Doe\\nBy: ________________________ John Doe\\nDate: February 27, 2024\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x70284c0c2dfa98a972c5c8cbe32a0b7f90b3b578;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between XYZ Tech Solutions, Inc., a corporation organized and existing under the laws of the State of New York, having its principal place of business at 789 Tech Avenue, New York, referred to as the \"Company,\" and Jane Smith, an individual residing at 123 Elm Street, New York, referred to as the \"Employee.\"\\n1. Position and Duties: 1.1 The Company hereby employs the Employee as a Software Engineer. The Employee shall perform all duties and responsibilities assigned by the Company related to this position.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and continue for a period of one year, terminating on February 27, 2025, unless terminated earlier as provided herein The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $6,500 per month, payable on the last business day of each month, via direct deposit to the Employee's bank account or USDC wallet address: 0x70284c0c2dfa98a972c5c8cbe32a0b7f90b3b578.\\n4. Termination: 4.1 Either party may terminate this Contract upon written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality and Non-Compete: 5.1 During the term of employment and thereafter, the Employee shall not disclose any confidential information belonging to the Company or engage in any activities that may compete with the Company's business interests.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of New York.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nXYZ Tech Solutions, Inc.\\nBy: [Authorized Signatory]\\nJane Smith\\nBy: ________________________ Jane Smith\\nDate: February 27, 2024\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x1714400ff23db4af24f9fd64e7039e6597f18c2b;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between Stellar Innovations LLC, a limited liability company organized and existing under the laws of the State of California, having its principal place of business at 456 Innovation Boulevard, San Francisco, referred to as the \"Company,\" and Michael Johnson, an individual residing at 789 Elm Street, San Francisco, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Marketing Manager. The Employee shall be responsible for developing and implementing marketing strategies, managing campaigns, and analyzing market trends.\\n2. Employment Period: 2.1 The employment shall commence on February 27, 2024, and shall continue for a period of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $7,000 per month, payable in bi-weekly installments via direct deposit to the Employee's bank account or USDC wallet address: 0x1714400ff23db4af24f9fd64e7039e6597f18c2b.\\n4. Termination: 4.1 Either party may terminate this Contract upon written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality Agreement: 5.1 The Employee agrees to maintain the confidentiality of all proprietary information belonging to the Company both during and after the term of employment.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nStellar Innovations LLC\\nBy: [Authorized Signatory]\\nMichael Johnson\\nBy: ________________________ Michael Johnson\\nDate: February 27, 2024\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x3dd1d15b3c78d6acfd75a254e857cbe5b9ff0af2;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "mployment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between TechGenius Inc., a corporation organized and existing under the laws of the State of Texas, with its principal place of business at 789 Tech Way, Austin, referred to as the \"Company,\" and Sarah Adams, an individual residing at 123 Oak Street, Austin, referred to as the \"Employee.\"\\n1. Position and Duties: 1.1 The Company hereby employs the Employee as a Senior Software Developer. The Employee shall be responsible for designing, developing, and maintaining software applications according to the Company's specifications.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and shall continue for an initial term of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $8,000 per month, payable semi-monthly via direct deposit to the Employee's bank account or USDC wallet address: 0x3dd1d15b3c78d6acfd75a254e857cbe5b9ff0af2.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality and Non-Compete: 5.1 The Employee agrees not to disclose any confidential information of the Company and not to engage in any competitive activities during the term of employment and for a period of one year thereafter.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of Texas.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nTechGenius Inc.\\nBy: [Authorized Signatory]\\nSarah Adams\\nBy: ________________________ Sarah Adams\\nDate: February 27, 2024\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xb0f6ca40411360c03d41c5ffc5f179b8403cdcf8;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 4500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between InnovateTech Solutions Ltd., a company organized and existing under the laws of the United Kingdom, with its principal place of business at 123 Innovation Street, London, referred to as the \"Company,\" and David Miller, an individual residing at 456 Maple Avenue, London, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Financial Analyst. The Employee shall be responsible for conducting financial analysis, preparing reports, and providing strategic recommendations to the management team.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and shall continue for an initial term of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $4,500 per month, payable monthly via direct deposit to the Employee's bank account or USDC wallet address: 0xb0f6ca40411360c03d41c5ffc5f179b8403cdcf8.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality and Non-Compete: 5.1 The Employee agrees not to disclose any confidential information of the Company and not to engage in any competitive activities during the term of employment and for a period of one year thereafter.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of England and Wales.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nInnovateTech Solutions Ltd.\\nBy: [Authorized Signatory]\\nDavid Miller\\nBy: ________________________ David Miller\\nDate: February 27, 2024\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x51c72848c68a965f66fa7a88855f9f7784502a7f;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6200; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between BrightFuture Enterprises, Inc., a corporation organized and existing under the laws of the State of California, with its principal place of business at 789 Sunshine Avenue, Los Angeles, referred to as the \"Company,\" and Emily Johnson, an individual residing at 456 Oak Street, Los Angeles, referred to as the \"Employee.\"\\n1. Position and Duties: 1.1 The Company hereby employs the Employee as a Human Resources Manager. The Employee shall be responsible for recruitment, employee relations, and compliance with labor laws and company policies.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and shall continue for an initial term of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $6,200 per month, payable bi-weekly via direct deposit to the Employee's bank account or USDC wallet address: 0x51c72848c68a965f66fa7a88855f9f7784502a7f.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality Agreement: 5.1 The Employee agrees not to disclose any confidential information of the Company, including but not limited to employee records and business strategies.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nBrightFuture Enterprises, Inc.\\nBy: [Authorized Signatory]\\nEmily Johnson\\nBy: ________________________ Emily Johnson\\nDate: February 27, 2024\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xd7a827fbaf38c98e8336c5658e4bcbcd20a4fd2d;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between NextWave Technologies, Inc., a corporation organized and existing under the laws of the State of New York, with its principal place of business at 789 Tech Avenue, New York City, referred to as the \"Company,\" and Alex Williams, an individual residing at 123 Maple Street, Brooklyn, New York, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Senior Project Manager. The Employee shall be responsible for overseeing project timelines, budgets, and deliverables, and ensuring effective communication among team members.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and shall continue for an initial term of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $7,500 per month, payable on the last business day of each month via direct deposit to the Employee's bank account or USDC wallet address: 0xd7a827fbaf38c98e8336c5658e4bcbcd20a4fd2d.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality Agreement: 5.1 The Employee agrees not to disclose any confidential information of the Company, including but not limited to proprietary project details and client information.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of New York.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nNextWave Technologies, Inc.\\nBy: [Authorized Signatory]\\nAlex Williams\\nBy: ________________________ Alex Williams\\nDate: February 27, 2024\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x9c2433dfd71096c435be9465220bb2b189375ea7;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between Quantum Dynamics Ltd., a company organized and existing under the laws of the United Kingdom, with its principal place of business at 456 Quantum Street, London, referred to as the \"Company,\" and Sarah Thompson, an individual residing at 789 Electron Avenue, London, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Senior Data Scientist. The Employee shall be responsible for analyzing complex data sets, developing machine learning models, and providing insights to support business decisions.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and shall continue for an initial term of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of £6,000 per month, payable monthly via direct deposit to the Employee's bank account or USDC wallet address: 0x9c2433dfd71096c435be9465220bb2b189375ea7.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality Agreement: 5.1 The Employee agrees not to disclose any confidential information of the Company, including but not limited to proprietary algorithms and research findings.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of England and Wales.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nQuantum Dynamics Ltd.\\nBy: [Authorized Signatory]\\nSarah Thompson\\nBy: ________________________ Sarah Thompson\\nDate: February 27, 2024\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xf8f3160d4d85c92cdf5fd59846923465cc1f2671;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEmployment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between Global Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal place of business at 123 Innovation Drive, San Francisco, referred to as the \"Company,\" and Mark Johnson, an individual residing at 456 Elm Street, San Francisco, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Senior Financial Analyst. The Employee shall be responsible for financial planning, analysis, and reporting to support strategic decision-making within the organization.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and shall continue for an initial term of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $8,000 per month, payable bi-weekly via direct deposit to the Employee's bank account or USDC wallet address: 0xf8f3160d4d85c92cdf5fd59846923465cc1f2671.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality Agreement: 5.1 The Employee agrees not to disclose any confidential information of the Company, including but not limited to financial data and strategic plans.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nGlobal Solutions Inc.\\nBy: [Authorized Signatory]\\nMark Johnson\\nBy: ________________________ Mark Johnson\\nDate: February 27, 2024\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x5c49ffae69c8146f1b6553a8fbd925778390f776;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 9000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between TechNex Corporation, a corporation organized and existing under the laws of the State of Texas, with its principal place of business at 789 Innovation Avenue, Austin, referred to as the \"Company,\" and Jennifer Lee, an individual residing at 456 Elm Street, Austin, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Senior Software Engineer. The Employee shall be responsible for designing, developing, and maintaining software systems to meet the Company's technical requirements.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and shall continue for an initial term of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $9,000 per month, payable monthly via direct deposit to the Employee's bank account or USDC wallet address: 0x5c49ffae69c8146f1b6553a8fbd925778390f776.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality Agreement: 5.1 The Employee agrees not to disclose any confidential information of the Company, including but not limited to proprietary algorithms and trade secrets.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of Texas.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nTechNex Corporation\\nBy: [Authorized Signatory]\\nJennifer Lee\\nBy: ________________________ Jennifer Lee\\nDate: February 27, 2024\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x6bd780e7fdf01d77e4d475c821f1e7ae05409072;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 9000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1708992000; // Unix timestamp of Tue Feb 27 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740614400; // Unix timestamp of Thu Feb 27 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of February 27, 2024, by and between TechNex Corporation, a corporation organized and existing under the laws of the State of Texas, with its principal place of business at 789 Innovation Avenue, Austin, referred to as the \"Company,\" and Jennifer Lee, an individual residing at 456 Elm Street, Austin, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Senior Software Engineer. The Employee shall be responsible for designing, developing, and maintaining software systems to meet the Company's technical requirements. The Employee shall also participate in team meetings, provide technical guidance to junior developers, and collaborate with other departments as necessary.\\n2. Term of Employment: 2.1 The employment shall commence on February 27, 2024, and shall continue for an initial term of one year, terminating on February 27, 2025, unless terminated earlier as provided herein. Upon the expiration of the initial term, this Contract may be renewed by mutual agreement of the parties. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $9,000 per month, payable monthly via direct deposit to the Employee's bank account or USDC wallet address: 0x6bd780e7fdf01d77e4d475c821f1e7ae05409072. The Employee shall be entitled to any bonuses or additional compensation as determined by the Company's policies.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. In the event of termination, the Employee shall be entitled to any accrued but unpaid salary and benefits up to the date of termination.\\n4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality Agreement: 5.1 The Employee agrees not to disclose any confidential information of the Company, including but not limited to proprietary algorithms, trade secrets, customer lists, and financial data. This obligation of confidentiality shall continue both during and after the term of employment.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of Texas. Any disputes arising out of or relating to this Contract shall be resolved exclusively through arbitration in accordance with the rules of the American Arbitration Association.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nTechNex Corporation\\nBy: [Authorized Signatory]\\nJennifer Lee\\nBy: ________________________ Jennifer Lee\\nDate: February 27, 2024\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xbe3ad6a5669dc0b8b12febc03608860c31e2eef6;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1709164800; // Unix timestamp of Thu Feb 29 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740700800; // Unix timestamp of Fri Feb 28 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Acme Technologies Corp. (Hereinafter referred to as \"Employer\")\\nAnd John Smith Address: 123 Main Street, Anytown, USA (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Senior Software Engineer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on February 29, 2024, and shall terminate on February 28, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $100,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xbe3ad6a5669dc0b8b12febc03608860c31e2eef6. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: ______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x5c84cf4d91dc0acde638363ec804792bb2108258;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 3000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1707004800; // Unix timestamp of Sun Feb 04 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 2030050800; // Unix timestamp of Mon May 01 2034 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of 04.02.2024, by and between Antony’s Limited, a corporation organized and existing under the laws of Freed Palestinian Khalifat, with its principal place of business at Hayfa City, Palestine, 1038/42, referred to as the \"Company,\" and Shahid Alsalibi, an individual residing at Green street 43, Al-quds, 3812/3278, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Junior AI Developer. The Employee shall perform all duties and responsibilities related to this position as assigned by the Company. This includes but is not limited to training company’s AI classifiers.\\n2. Term of Employment: 2.1 The employment shall commence on 04.02.2024 and continue until 01.05.2034, unless terminated earlier in accordance with this Contract or extended by mutual agreement of the parties. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of 3000$ per month. Payment shall be made on a weekly basis via direct deposit to the Employee's designated bank account or USDC wallet address: 0x5c84cf4d91dc0acde638363ec804792bb2108258.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving [notice period] days' written notice to the other party, subject to any applicable employment laws. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality and Non-Disclosure: 5.1 During the term of employment and thereafter, the Employee agrees not to disclose or use any confidential information or trade secrets of the Company for personal gain or for the benefit of any third party.\\n6. Governing Law and Jurisdiction: 6.1 This Contract shall be governed by and construed in accordance with the laws of [State/Country]. Any disputes arising under or related to this Contract shall be subject to the exclusive jurisdiction of the courts of [State/Country].\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\n[Company Name]\\nBy: ________________________ [Authorized Signatory]\\n[Employee Name]\\nBy: ________________________ [Employee Signature]\\nDate: ________________________\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x1e3f1f1ca8c62aabcb3b78d87223e988dfa3780e;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1710028800; // Unix timestamp of Sun Mar 10 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n   // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into on this 10th day of March, 2024, by and between:\\nTechNex Enterprises 789 Technology Boulevard Seattle, WA 98101\\nHereinafter referred to as the \"Company,\"\\nand\\nEmma Davis 123 Software Street San Francisco, CA 94103\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Emma Davis, and Emma Davis hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Marketing Manager and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management. The employee is employed on a full-time basis.\\nStart Date: The employment of Emma Davis shall commence on March 10, 2024.\\nSalary: The Company agrees to pay Emma Davis a monthly salary of $5,500 (USD) on a weekly basis, payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0x1e3f1f1ca8c62aabcb3b78d87223e988dfa3780e.\\nBenefits: Emma Davis shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Emma Davis's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 60 days' written notice to the other party.\\nConfidentiality: Emma Davis agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of Washington.\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nTechNex Enterprises\\nBy: [Authorized Signatory] Title: HR Manager Date: March 10, 2024\\nEmma Davis\\nBy: _______________________ [Employee Signature] Date: _______________________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xcc4e4c18bad7e1cc63bb98915eeb3f412939955e;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1963094400; // Unix timestamp of Wed Mar 17 2032 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "This Employment Contract (\"Contract\") is made and entered into on this [Start Date], by and between:\\nInnovateTech Solutions Inc. Address: 456 Innovation Avenue, Suite 200 Tech City, TC 54321\\nHereinafter referred to as the \"Company,\"\\nand\\nAlexandra Nguyen Address: 789 Developer's Lane Coder Town, CT 67890\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Alexandra Nguyen, and Alexandra Nguyen hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Software Engineer and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management. The employee is employed on a full-time basis.\\nStart Date: The employment of Alexandra Nguyen shall commence on 17.03.2032.\\nSalary: The Company agrees to pay Alexandra Nguyen a monthly salary of $6,000 (USD), payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0xcc4e4c18bad7e1cc63bb98915eeb3f412939955e.\\nBenefits: Alexandra Nguyen shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Alexandra Nguyen's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 30 days' written notice to the other party.\\nConfidentiality: Alexandra Nguyen agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of Connecticut.\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nInnovateTech Solutions Inc.\\nBy: [Authorized Signatory] Title: [Authorized Signatory Title] Date: _______________________\\nAlexandra Nguyen\\nBy: _______________________ [Employee Signature] Date: _______________________\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xd9535bb5f58a1a75032416f2dfe7880c30575a41;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 4500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1797465600; // Unix timestamp of Thu Dec 17 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into on this [Start Date], by and between:\\nDynamic Marketing Solutions LLC Address: 789 Marketing Avenue Promotion City, PC 12345\\nHereinafter referred to as the \"Company,\"\\nand\\nMichael Thompson Address: 123 Advertiser's Lane Ad Town, AT 67890\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Michael Thompson, and Michael Thompson hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Marketing Specialist and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management. The employee is employed on a full-time basis.\\nStart Date: The employment of Michael Thompson shall commence on 17.12.2026.\\nSalary: The Company agrees to pay Michael Thompson a monthly salary of $4,500 (USD) on a weekly basis, payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0xd9535bb5f58a1a75032416f2dfe7880c30575a41.\\nBenefits: Michael Thompson shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Michael Thompson's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 30 days' written notice to the other party.\\nConfidentiality: Michael Thompson agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of [State].\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nDynamic Marketing Solutions LLC\\nBy: [Authorized Signatory] Title: [Authorized Signatory Title] Date: _______________________\\nMichael Thompson\\nBy: _______________________ [Employee Signature] Date: _______________________\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xc39d8c1f4e09133738a3f97c63c7e3300035d2bd;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6800; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1911250800; // Unix timestamp of Fri Jul 26 2030 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into on this [Start Date], by and between:\\nDigital Dynamics Inc. Address: 123 Tech Plaza Tech City, TC 54321\\nHereinafter referred to as the \"Company,\"\\nand\\nJessica Lee Address: 456 Programmer's Lane Coder Town, CT 67890\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Jessica Lee, and Jessica Lee hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Software Developer and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management.\\nStart Date: The employment of Jessica Lee shall commence on 26.07.2030.\\nSalary: The Company agrees to pay Jessica Lee a monthly salary of $6,800 (USD), payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0xc39d8c1f4e09133738a3f97c63c7e3300035d2bd.\\nBenefits: Jessica Lee shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Jessica Lee's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 30 days' written notice to the other party.\\nConfidentiality: Jessica Lee agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of Connecticut.\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nDigital Dynamics Inc.\\nBy: [Authorized Signatory] Title: [Authorized Signatory Title] Date: _______________________\\nJessica Lee\\nBy: _______________________ [Employee Signature] Date: _______________________\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x30afbcf9458c3131a6d051c621e307e6278e4110;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 2309212800; // Unix timestamp of Fri Mar 06 2043 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into on this [Start Date], by and between:\\nInnovative Solutions Group Address: 789 Innovation Avenue Tech City, TC 54321\\nHereinafter referred to as the \"Company,\"\\nand\\nDaniel Brown Address: 123 Developer's Lane Coder Town, CT 67890\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Daniel Brown, and Daniel Brown hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Web Developer and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management. The employee is employed on a full-time basis.\\nStart Date: The employment of Daniel Brown shall commence on 6.03.2043.\\nSalary: The Company agrees to pay Daniel Brown a monthly salary of $5,500 (USD) on a weekly basis, payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0x30afbcf9458c3131a6d051c621e307e6278e4110.\\nBenefits: Daniel Brown shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Daniel Brown's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 30 days' written notice to the other party.\\nConfidentiality: Daniel Brown agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of Connecticut.\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nInnovative Solutions Group\\nBy: [Authorized Signatory] Title: [Authorized Signatory Title] Date: _______________________\\nDaniel Brown\\nBy: _______________________ [Employee Signature] Date: _______________________\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xc86eb7b85807020b4548ee05b54bfc956eebbfcd;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 2813270400; // Unix timestamp of Mon Feb 24 2059 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Could be updated later on\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "This Employment Contract (\"Contract\") is made and entered into on this [Start Date], by and between:\\nTechGenius Innovations Ltd. Address: 123 Innovation Street Techville, TV 54321\\nHereinafter referred to as the \"Company,\"\\nand\\nSophia Johnson Address: 456 Developer's Lane Coder City, CC 67890\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Sophia Johnson, and Sophia Johnson hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Software Engineer and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management. The employee is employed on a full-time basis.\\nStart Date: The employment of Sophia Johnson shall commence on 24.02.2059.\\nSalary: The Company agrees to pay Sophia Johnson a monthly salary of $6,500 (USD), payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0xc86eb7b85807020b4548ee05b54bfc956eebbfcd.\\nBenefits: Sophia Johnson shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Sophia Johnson's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 30 days' written notice to the other party.\\nConfidentiality: Sophia Johnson agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of [State].\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nTechGenius Innovations Ltd.\\nBy: [Authorized Signatory] Title: [Authorized Signatory Title] Date: _______________________\\nSophia Johnson\\nBy: _______________________ [Employee Signature] Date: _______________________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee;\\n    address private authorizedApp = 0xe68ee8a12c611fd043fb05d65e1548dc1383f2b9; // Address of the authorized app to update metrics\\n    uint256 public salary = 6200; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1833926400; // Unix timestamp of Sat Feb 12 2028 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Couldbe updated later on.\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into on this [Start Date], by and between:\\nTechTrend Solutions Inc. Address: 789 Innovation Avenue Tech City, TC 54321\\nHereinafter referred to as the \"Company,\"\\nand\\nMatthew Reynolds Address: 123 Programmer's Lane Coder Town, CT 67890\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Matthew Reynolds, and Matthew Reynolds hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Software Developer and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management. The employee is employed on a full-time basis.\\nStart Date: The employment of Matthew Reynolds shall commence on 12.02.2028.\\nSalary: The Company agrees to pay Matthew Reynolds a monthly salary of $6,200 (USD) on a weekly basis, payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0xe68ee8a12c611fd043fb05d65e1548dc1383f2b9.\\nBenefits: Matthew Reynolds shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Matthew Reynolds's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 30 days' written notice to the other party.\\nConfidentiality: Matthew Reynolds agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of Connecticut.\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nTechTrend Solutions Inc.\\nBy: [Authorized Signatory] Title: [Authorized Signatory Title] Date: _______________________\\nMatthew Reynolds\\nBy: _______________________ [Employee Signature] Date: _______________________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x0b2402144bb366a632d14b83f244d2e0e21bd39c;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salar = 6800; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1714445593; // Unix timestamp of Tue Apr 30 2024 03:53:13 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Couldbe updated later on.\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Employment Contract\\nThis Employment Contract (\"Contract\") is made and entered into on this [Start Date], by and between:\\nInnovative Solutions Group Address: 123 Innovation Street Techville, TV 54321\\nHereinafter referred to as the \"Company,\"\\nand\\nNatalie Evans Address: 456 Programmer's Lane Coder City, CC 67890\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Natalie Evans, and Natalie Evans hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Software Engineer and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management. The employee is employed on a full-time basis.\\nStart Date: The employment of Natalie Evans shall commence on 30.04.2042.\\nSalary: The Company agrees to pay Natalie Evans a monthly salary of $6,800 (USD), payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0x0b2402144bb366a632d14b83f244d2e0e21bd39c.\\nBenefits: Natalie Evans shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Natalie Evans's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 30 days' written notice to the other party.\\nConfidentiality: Natalie Evans agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nInnovative Solutions Group\\nBy: [Authorized Signatory] Title: [Authorized Signatory Title] Date: _______________________\\nNatalie Evans\\nBy: _______________________ [Employee Signature] Date: _______________________\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xc657a1440d266dd21ec3c299a8b9098065f663bb;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1707969193; // Unix timestamp of Thu Feb 15 2024 03:53:13 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1771127593; // Unix timestamp of Sun Feb 15 2026 03:53:13 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of February 15, 2024, by and between TechSolutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Innovation Avenue, Tech City, CA 54321 (\"Company\"), and Sarah Johnson, (\"Employee\").\\nPOSITION AND DUTIES\\nThe Company hereby agrees to employ the Employee in the position of Senior Software Engineer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT\\nThe term of employment shall commence on February 15, 2024, and shall terminate on February 15, 2026, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY\\nThe Company shall pay the Employee a monthly salary of $7,500 USD on a weekly basis, payable in USDC to the Employee's wallet address as follows: 0xc657a1440d266dd21ec3c299a8b9098065f663bb. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY\\nThe Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW\\nThis Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: John Doe Name: John Doe Title: CEO\\nEMPLOYEE: Signature: Sarah Johnson Name: Sarah Johnson\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x8fe3842e0b7472a57f2a2d56cf6bce08517a1de0;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1719802393; // Unix timestamp of Mon Jul 01 2024 03:53:13 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1782787993; // Unix timestamp of Tue Jun 30 2026 03:53:13 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of July 1, 2024, by and between BrightTech Solutions Inc., a corporation organized and existing under the laws of the State of New York, with its principal office located at 456 Tech Boulevard, Techville, NY 12345 (\"Company\"), and David Thompson, (\"Employee\").\\nPOSITION AND DUTIES\\nThe Company hereby agrees to employ the Employee in the position of Marketing Manager. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT\\nThe term of employment shall commence on July 1, 2024, and shall terminate on June 30, 2026, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY\\nThe Company shall pay the Employee a monthly salary of $6,000 USD, payable in USDC to the Employee's wallet address as follows: 0x8fe3842e0b7472a57f2a2d56cf6bce08517a1de0. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY\\nThe Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW\\nThis Contract shall be governed by and construed in accordance with the laws of the State of New York.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: Jane Smith Name: Jane Smith Title: HR Manager\\nEMPLOYEE: Signature: David Thompson Name: David Thompson\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xaa0e2529f9c33e3ad86346fe26fefc4bc635fc67;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5200; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1709265193; // Unix timestamp of Fri Mar 01 2024 03:53:13 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1772250793; // Unix timestamp of Sat Feb 28 2026 03:53:13 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of March 1, 2024, by and between CyberSolutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Data Drive, Tech Town, CA 98765 (\"Company\"), and Emily Parker, (\"Employee\").\\nPOSITION AND DUTIES\\nThe Company hereby agrees to employ the Employee in the position of Data Analyst. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT\\nThe term of employment shall commence on March 1, 2024, and shall terminate on February 28, 2026, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY\\nThe Company shall pay the Employee a monthly salary of $5,200 USD on a weekly basis, payable in USDC to the Employee's wallet address as follows: 0xaa0e2529f9c33e3ad86346fe26fefc4bc635fc67. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY\\nThe Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW\\nThis Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: Mark Johnson Name: Mark Johnson Title: Human Resources Manager\\nEMPLOYEE: Signature: Emily Parker Name: Emily Parker\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xb9f33349db1d0711d95c1198acba9511b8269626;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8333; // Monthly salary amount in USDC ($100,000 USD per annum)\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1709164800; // Unix timestamp of Thu Feb 29 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1740700800; // Unix timestamp of Fri Feb 28 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "Fixed-Term Employment Contract\\nBetween Acme Technologies Corp. (Hereinafter referred to as \"Employer\")\\nAnd John Smith Address: 123 Main Street, Anytown, USA (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Senior Software Engineer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on February 29, 2024, and shall terminate on February 28, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $100,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xb9f33349db1d0711d95c1198acba9511b8269626. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: ______________\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x3a582652e71258990a92f8e31c3620408958e630;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6800; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1724108400; // Unix timestamp of Tue Aug 20 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1751842800; // Unix timestamp of Mon Jul 07 2025 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of [Start Date], by and between TechNex Solutions LLC, a corporation organized and existing under the laws of the State of California, with its principal office located at 123 Tech Avenue, Silicon Valley, CA 98765 (\"Company\"), and Samantha Roberts, (\"Employee\").\\nPOSITION AND DUTIES\\nThe Company hereby agrees to employ the Employee in the position of Project Manager. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT\\nThe term of employment shall commence on 20.08.2024, and shall terminate on 7.07.2025, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY\\nThe Company shall pay the Employee a monthly salary of $6,800 USD, payable in USDC to the Employee's wallet address as follows: 0x3a582652e71258990a92f8e31c3620408958e630. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY\\nThe Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW\\nThis Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: Samantha Roberts Name: Samantha Roberts\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xb6ad6ac30b92ce8d023f8f303a43172cc34d97bc;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1705276800; // Unix timestamp of Mon Jan 15 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1768435200; // Unix timestamp of Thu Jan 15 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of January 15, 2024, by and between Digital Innovations Inc., a corporation organized and existing under the laws of the State of New York, with its principal office located at 789 Tech Avenue, Tech City, NY 54321 (\"Company\"), and John Smith, (\"Employee\").\\nPOSITION AND DUTIES\\nThe Company hereby agrees to employ the Employee in the position of Senior Software Developer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT\\nThe term of employment shall commence on January 15, 2024, and shall terminate on January 15, 2026, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY\\nThe Company shall pay the Employee a monthly salary of $7,000 USD, payable in USDC to the Employee's wallet address as follows: 0xb6ad6ac30b92ce8d023f8f303a43172cc34d97bc. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY\\nThe Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW\\nThis Contract shall be governed by and construed in accordance with the laws of the State of New York.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: Michael Johnson Name: Michael Johnson Title: Human Resources Manager\\nEMPLOYEE: Signature: John Smith Name: John Smith\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x02944e3fb72aa13095d7cebd8389fc74bec8e48e;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1705276800; // Unix timestamp of Mon Jan 15 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1768435200; // Unix timestamp of Thu Jan 15 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of January 15, 2024, by and between Digital Innovations Inc., a corporation organized and existing under the laws of the State of New York, with its principal office located at 789 Tech Avenue, Tech City, NY 54321 (\"Company\"), and John Smith, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Software Developer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on January 15, 2024, and shall terminate on January 15, 2026, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $7,000 USD, payable in USDC to the Employee's wallet address as follows: 0x02944e3fb72aa13095d7cebd8389fc74bec8e48e. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of New York.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: Michael Johnson Name: Michael Johnson Title: Human Resources Manager\\nEMPLOYEE: Signature: John Smith Name: John Smith\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x346d1cfc5804a7957219c5b625a0e03ab0434147;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 5500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1714604400; // Unix timestamp of Thu May 02 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1990828800; // Unix timestamp of Tue Feb 01 2033 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n   // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of [Start Date], by and between Innovative Solutions LLC, a corporation organized and existing under the laws of the State of California, with its principal office located at 456 Innovation Street, Tech Town, CA 98765 (\"Company\"), and Emily Davis, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Marketing Coordinator. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 02.05.24 and shall terminate on 01.02.2033, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $5,500 USD, payable in USDC to the Employee's wallet address as follows: 0x346d1cfc5804a7957219c5b625a0e03ab0434147. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Emily Davis\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x3e398904a78316731729ee5640175f59dc5b8867;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1770940800; // Unix timestamp of Fri Feb 13 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1875913200; // Unix timestamp of Tue Jun 12 2029 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of [Start Date], by and between TechWorks Inc., a corporation organized and existing under the laws of the State of Texas, with its principal office located at 123 Tech Avenue, Tech City, TX 54321 (\"Company\"), and Alex Johnson, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Software Engineer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 13.2.2026 and shall terminate on 12.06.2029, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $8,000 USD, payable in USDC to the Employee's wallet address as follows: 0x3e398904a78316731729ee5640175f59dc5b8867. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of Texas.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Alex Johnson\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x85b7fb279a888c56163275df5a2caa03cbe467fd;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1771372800; // Unix timestamp of Wed Feb 18 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 2120947200; // Unix timestamp of Wed Mar 18 2037 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    /// Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 18.2.2026, by and between TechGenius Solutions LLC, a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Innovation Avenue, Tech Town, CA 54321 (\"Company\"), and Sarah Lee, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Marketing Specialist. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 18.2.2026 and shall terminate on 18.03.2037, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $6,500 USD, payable in USDC to the Employee's wallet address as follows: 0x85b7fb279a888c56163275df5a2caa03cbe467fd. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Sarah Lee\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xf94ea5b18401821be07fbff535b8211b061a7f70;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1699660800; // Unix timestamp of Sat Nov 11 2023 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1711238400; // Unix timestamp of Sun Mar 24 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary);\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of [Start Date], by and between TechGenie Innovations Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 123 Tech Avenue, Tech City, CA 54321 (\"Company\"), and Michael Smith, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Software Developer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 11.11.2023 and shall terminate on 24.03.2024, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $8,500 USD, payable in USDC to the Employee's wallet address as follows: 0xf94ea5b18401821be07fbff535b8211b061a7f70. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Michael Smith\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xd315a9c38ec871068fec378e4ce78af528c76293;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6800; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1712962800; // Unix timestamp of Sat Apr 13 2024 00:00:00 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 1766188800; // Unix timestamp of Sat Dec 20 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 13/04/2024, by and between NextGen Solutions LLC, a corporation organized and existing under the laws of the State of California, with its principal office located at 456 Innovation Street, Tech City, CA 54321 (\"Company\"), and Jessica Martinez, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Marketing Manager. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 13/4/2024 and shall terminate on 20/12/2025, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $6,800 USD, payable on a weekly basis in USDC to the Employee's wallet address as follows: 0xd315a9c38ec871068fec378e4ce78af528c76293. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Jessica Martinez\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x34a175853c62c60460059be615bf451176eec768;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8200; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1785085658; // Unix timestamp of Sun Jul 26 2026 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 2200842458; // Unix timestamp of Wed Sep 28 2039 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of [Start Date], by and between BrightHorizon Technologies Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Innovation Avenue, Tech Town, CA 54321 (\"Company\"), and David Thompson, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Software Engineer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 26.07.2026 and shall terminate on 28.09.2039, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $8,200 USD, payable on a weekly basis in USDC to the Employee's wallet address as follows: 0x34a175853c62c60460059be615bf451176eec768. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: David Thompson\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x1627644d3c31eef0fd97978d41d439c3a322c953;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1735754858; // Unix timestamp of Wed Jan 01 2025 18:07:38 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1877879258; // Unix timestamp of Wed Jul 04 2029 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of [Start Date], by and between InnovateTech Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 123 Innovation Street, Tech City, CA 54321 (\"Company\"), and Emma Johnson, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Project Manager. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 01.01.2025 and shall terminate on 04.07.2029, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $7,500 USD, payable on a weekly basis in USDC to the Employee's wallet address as follows: 0x1627644d3c31eef0fd97978d41d439c3a322c953. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Emma Johnson\\na"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xc4f96f5c072ff4dc9691963b93ce5b128ad802af;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1903453658; // Unix timestamp of Fri Apr 26 2030 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 2240590058; // Unix timestamp of Mon Dec 31 2040 18:07:38 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 26.04.2030, by and between TechAdvance Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 456 Tech Boulevard, Tech Town, CA 98765 (\"Company\"), and Jason Miller, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Data Analyst. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 26.04.2030 and shall terminate on 31.12.2040, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $7,000 USD, payable on a weekly basis in USDC to the Employee's wallet address as follows: 0xc4f96f5c072ff4dc9691963b93ce5b128ad802af. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Jason Miller\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x721f37495cd70383b0a77bf1eb8f97eef29498bb;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1819040858; // Unix timestamp of Mon Aug 23 2027 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 2048090858; // Unix timestamp of Sat Nov 25 2034 18:07:38 GMT+0000 (Greenwich Mean Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 23.08.2027, by and between BrightTech Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Tech Avenue, Tech City, CA 54321 (\"Company\"), and Sarah Johnson, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Software Engineer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 23.08.2027 and shall terminate on 25.11.2034, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $8,000 USD, payable on a weekly basis in USDC to the Employee's wallet address as follows: 0x721f37495cd70383b0a77bf1eb8f97eef29498bb. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Sarah Johnson\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xc473e2aee3441bf9240be85eb122abb059a3b57c;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 8500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 2058887258; // Unix timestamp of Fri Mar 30 2035 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 2381504858; // Unix timestamp of Mon Jun 19 2045 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "EMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 30.03.2035, by and between TechNex Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Tech Avenue, Tech City, CA 54321 (\"Company\"), and Alex Johnson, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Software Engineer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 30.03.2035 and shall terminate on 19.06.2045, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $8,500 USD, payable on a bi-weekly basis in USDC to the Employee's wallet address as follows: 0xc473e2aee3441bf9240be85eb122abb059a3b57c. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Alex Johnson\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xf28f96ebb56c34e40aabf6553ad92413e7835f5b;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 6500; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1704737258; // Unix timestamp of Mon Jan 08 2024 18:07:38 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1882544858; // Unix timestamp of Mon Aug 27 2029 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 8/01/2024, by and between InnovateTech Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 123 Innovation Street, Tech City, CA 54321 (\"Company\"), and Rachel Thompson, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Marketing Coordinator. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 8/01/2024 and shall terminate on 27/08/2029, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $6,500 USD, payable on a bi-weekly basis in USDC to the Employee's wallet address as follows: 0xf28f96ebb56c34e40aabf6553ad92413e7835f5b. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Rachel Thompson\\nTop of Form\\nBottom of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0xee5f2e39d8abf28e449327bfd44317fc500eb4d8;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7200; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 1705082858; // Unix timestamp of Fri Jan 12 2024 18:07:38 GMT+0000 (Greenwich Mean Time)\\n    uint256 public terminationDate = 1809104858; // Unix timestamp of Fri Apr 30 2027 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 12.01.2024, by and between BrightPath Technologies Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Tech Avenue, Tech City, CA 54321 (\"Company\"), and Michael Brown, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Data Analyst. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 12.01.2024 and shall terminate on 30.04.2027, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $7,200 USD, payable on a bi-weekly basis in USDC to the Employee's wallet address as follows: 0xee5f2e39d8abf28e449327bfd44317fc500eb4d8. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Michael Brown\\nTop of Form\\n"
    },
    {
        "smart_contract": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\\n\\ncontract EmploymentContract is ReentrancyGuard {\\n    address public employer;\\n    address public employee = 0x4cd207d3bb951dffee3fae27a0be70019bb72666;\\n    address private authorizedApp; // Address of the authorized app to update metrics\\n    uint256 public salary = 7000; // Monthly salary amount in USDC\\n    IERC20 private usdcToken; // USDC token contract interface\\n    uint256 public startDate = 2036077658; // Unix timestamp of Sun Jul 09 2034 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public terminationDate = 2230823258; // Unix timestamp of Sun Sep 09 2040 18:07:38 GMT+0100 (British Summer Time)\\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\\n    uint256 public performanceThreshold = 0; \\n    bool public isEmployed = true; // Employment status\\n    string public salaryType = 'bi-weekly'; // How often a salary payment to be initiated\\n    \\n    event SalaryUpdated(uint256 newSalary);\\n    event BonusPaid(uint256 bonusAmount);\\n    event EmploymentTerminated(string message);\\n    event DisputeResolved(string message);\\n    event SalaryPaid(uint256 amount);\\n    event PerformanceScoreUpdated(uint256 score);\\n    event PerformanceThresholdUpdated(uint256 threshold);\\n    event TerminationDateUpdated(uint256 newTerminationDate);\\n\\n    modifier onlyAuthorizedApp() {\\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _authorizedApp,\\n        address _usdcTokenAddress\\n    ) {\\n        employer = msg.sender; // The address deploying the contract is the employer\\n        authorizedApp = _authorizedApp;\\n        usdcToken = IERC20(_usdcTokenAddress);\\n        lastSalaryPaidDate = startDate; // Initialize with start date\\n    }\\n\\n    // Function to deposit USDC into the contract for salary payments\\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    // Function to automatically withdraw monthly salary funds from the employer\\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\\n        uint256 shortfall = 0;\\n\\n        if (currentBalance < amountNeeded) {\\n            shortfall = amountNeeded - currentBalance;\\n            // Attempt to transfer the shortfall from the employer to the contract\\n            usdcToken.transferFrom(employer, address(this), shortfall);\\n        }\\n    }\\n\\n    // Automatically pay salary on a monthly basis\\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\\n        require(isEmployed, \"Employment has ended\");\\n        require(block.timestamp >= lastSalaryPaidDate + 14 days, \"Salary already paid for this period\");\\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\\n\\n        lastSalaryPaidDate += 14 days; // Update last salary paid date to current month\\n        usdcToken.transfer(employee, salary / 2.2); // Since there are 4.4 weeks in a months and the pay is bi-weekly\\n        emit SalaryPaid(salary);\\n    }\\n\\n    // Update performance score\\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\\n        performanceScore = _newScore;\\n        emit PerformanceScoreUpdated(_newScore);\\n    }\\n\\n    // Update performance threshold \\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\\n        performanceThreshold = _threshold;\\n        emit PerformanceThresholdUpdated(_threshold);\\n    }\\n\\n    // Extend employment termination date\\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\\n        terminationDate = _newTerminationDate;\\n        emit TerminationDateUpdated(_newTerminationDate);\\n    }\\n\\n    // Update salary\\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\\n        salary = _newSalary;\\n        emit SalaryUpdated(_newSalary);\\n    }\\n\\n    // Pay bonus\\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\\n        usdcToken.transfer(employee, _bonusAmount);\\n        emit BonusPaid(_bonusAmount);\\n    }\\n\\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\\n        if (employeePermission && employerPermission) {\\n            // If both parties agree, terminate employment and notify\\n            isEmployed = false;\\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\\n        } else {\\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\\n            _resolveDispute(employerFault);\\n        }\\n    }\\n\\n    // Function to check contract balance (for employer's view)\\n    function checkContractBalance() external view returns (uint256) {\\n        return usdcToken.balanceOf(address(this));\\n    }\\n\\n    // Additional function to handle disputes and protect the salary buffer\\n    function _resolveDispute(bool employerFault) internal {\\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\\n        address recipient = employerFault ? employee : employer;\\n        usdcToken.transfer(recipient, contractBalance);\\n\\n        isEmployed = false;\\n\\n        string memory resolutionMessage = employerFault \\n            ? \"Employer at fault, funds transferred to employee.\" \\n            : \"Employee at fault, funds transferred to employer.\";\\n        emit DisputeResolved(resolutionMessage);\\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\\n    }\\n\\n    // External interface for dispute resolution, callable by authorized app\\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\\n        _resolveDispute(employerFault);\\n    }\\n}\\n",
        "legal_contract": "\\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 07.09.2034, by and between InnovateTech Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 123 Innovation Street, Tech City, CA 54321 (\"Company\"), and Jessica Miller, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Marketing Manager. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 07.09.2034 and shall terminate on 09.09.2040, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $7,000 USD, payable on a bi-weekly basis in USDC to the Employee's wallet address as follows: 0x4cd207d3bb951dffee3fae27a0be70019bb72666. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Jessica Miller\\nTop of Form\\n"
    }
]