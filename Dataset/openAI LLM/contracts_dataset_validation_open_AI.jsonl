{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\n\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 23.08.2027, by and between BrightTech Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Tech Avenue, Tech City, CA 54321 (\"Company\"), and Sarah Johnson, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Senior Software Engineer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 23.08.2027 and shall terminate on 25.11.2034, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $8,000 USD, payable on a weekly basis in USDC to the Employee's wallet address as follows: 0x721f37495cd70383b0a77bf1eb8f97eef29498bb. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Sarah Johnson\\nTop of Form\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0x721f37495cd70383b0a77bf1eb8f97eef29498bb;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 8000; // Monthly salary amount in USDC\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1819040858; // Unix timestamp of Mon Aug 23 2027 18:07:38 GMT+0100 (British Summer Time)\n    uint256 public terminationDate = 2048090858; // Unix timestamp of Sat Nov 25 2034 18:07:38 GMT+0000 (Greenwich Mean Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; \n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    // Update performance threshold \n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of 12.03.2026, by and between InnovateTech Solutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 123 Innovation Street, Tech City, CA 54321 (\"Company\"), and Michael Davis, (\"Employee\").\\nPOSITION AND DUTIES The Company hereby agrees to employ the Employee in the position of Marketing Manager. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT The term of employment shall commence on 12.03.2026 and shall terminate on 20.06.2057, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY The Company shall pay the Employee a monthly salary of $7,000 USD, payable on a weekly basis in USDC to the Employee's wallet address as follows: 0x1f4d70d81484c6cc6c5f78af41e54e80ae240ff5. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY The Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: [Authorized Signatory] Name: [Name of Authorized Company Representative] Title: [Title of Authorized Company Representative]\\nEMPLOYEE: Signature: ____________________________ Name: Michael Davis\\nTop of Form\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0x1f4d70d81484c6cc6c5f78af41e54e80ae240ff5;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 7000; // Monthly salary amount in USDC\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1773338858; // Unix timestamp of Thu Mar 12 2026 18:07:38 GMT+0000 (Greenwich Mean Time)\n    uint256 public terminationDate = 2760282458; // Unix timestamp of Wed Jun 20 2057 18:07:38 GMT+0100 (British Summer Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; \n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    // Update performance threshold \n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\nFixed-Term Employment Contract\\nBetween Innovative Solutions Co. (Hereinafter referred to as \"Employer\")\\nAnd Emma Davis Address: 789 Pine Street, Lakeside, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Financial Analyst. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on April 15, 2025, and shall terminate on April 14, 2026, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $75,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xae1ec28d6225dce2ff787dcb8ce11cf6d3ae064f. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0xae1ec28d6225dce2ff787dcb8ce11cf6d3ae064f;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 6250; // Monthly salary amount in USDC ($75,000 USD per annum)\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1744671600; // Unix timestampf of Tue Apr 15 2025 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public terminationDate = 1776121200; // Unix timestamp of Tue Apr 14 2026 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n        \n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary);\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\nFixed-Term Employment Contract\\nBetween Tech Innovations Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Benjamin Martinez Address: 456 Cedar Street, Hilltop, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Software Engineer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on May 1, 2025, and shall terminate on April 30, 2026, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $90,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x8bb6cae3f1cada07dd14ba951e02886ea6bba183. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0x8bb6cae3f1cada07dd14ba951e02886ea6bba183;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 7500; // Monthly salary amount in USDC ($90,000 USD per annum)\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1746054000; // Unix timestamp of Thu May 01 2025 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public terminationDate = 1777503600; // Unix timestamp of Thu Apr 30 2026 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary);\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\n\nEmployment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of April 3, 2024, by and between InnovateNow Solutions LLC, a limited liability company organized and existing under the laws of the State of Texas, with its principal place of business at 123 Innovation Avenue, Austin, referred to as the \"Company,\" and John Davis, an individual residing at 456 Elm Street, Austin, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Senior Software Developer. The Employee shall be responsible for designing, coding, and testing software applications, as well as providing technical support and guidance to junior developers.\\n2. Term of Employment: 2.1 The employment shall commence on April 3, 2024, and shall continue for an initial term of one year, terminating on April 3, 2025, unless terminated earlier as provided herein. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of $8,500 per month. Payment shall be made on a monthly basis via direct deposit to the Employee's bank account or USDC wallet address: 0x2487cb1a359c942312259bbc64a01cee32e9f539.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving 30 days' written notice to the other party. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality Agreement: 5.1 The Employee agrees not to disclose any confidential information of the Company, including but not limited to source code, proprietary algorithms, and client data.\\n6. Governing Law: 6.1 This Contract shall be governed by and construed in accordance with the laws of the State of Texas.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nInnovateNow Solutions LLC.\\nBy: [Authorized Signatory]\\nJohn Davis\\nBy: ________________________ [Employee Signature]\\nDate: April 3, 2024\\nTop of Form\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0x2487cb1a359c942312259bbc64a01cee32e9f539;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 8500; // Monthly salary amount in USDC\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1712098800; // Unix timestamp of Wed Apr 03 2024 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public terminationDate = 1743634800; // Unix timestamp of Thu Apr 03 2025 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; \n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary);\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    // Update performance threshold \n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\n\nEmployment Contract\\nThis Employment Contract (\"Contract\") is made and entered into as of [Start Date], by and between IBM, a corporation organized and existing under the laws of UK, with its principal place of business at London Bridge, SE1, referred to as the \"Company,\" and Ezzat Filistini, an individual residing at 38 Kingsdown road, E15 9WL, referred to as the \"Employee.\"\\n1. Position and Responsibilities: 1.1 The Company hereby employs the Employee as a Senior Software developer. The Employee shall perform all duties and responsibilities related to this position as assigned by the Company. This includes but is not limited to producing software.\\n2. Term of Employment: 2.1 The employment shall commence on 9.12.2026 and continue until 01.05.2040, unless terminated earlier in accordance with this Contract or extended by mutual agreement of the parties. The employee is employed on a full-time basis.\\n3. Compensation: 3.1 In consideration of the services provided, the Company agrees to pay the Employee a salary of 10000$ per month. Payment shall be made on a monthly basis via direct deposit to the Employee's bank account or USDC wallet address: 0x41dda7be30130cebd867f439a759b9e7ab2569e9.\\n4. Termination: 4.1 Either party may terminate this Contract upon giving [notice period] days' written notice to the other party, subject to any applicable employment laws. 4.2 The Company reserves the right to terminate the Employee's employment immediately for cause, including but not limited to gross misconduct, violation of Company policies, or failure to perform duties satisfactorily.\\n5. Confidentiality and Non-Disclosure: 5.1 During the term of employment and thereafter, the Employee agrees not to disclose or use any confidential information or trade secrets of the Company for personal gain or for the benefit of any third party.\\n6. Governing Law and Jurisdiction: 6.1 This Contract shall be governed by and construed in accordance with the laws of [State/Country]. Any disputes arising under or related to this Contract shall be subject to the exclusive jurisdiction of the courts of [State/Country].\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\n[Company Name]\\nBy: ________________________ [Authorized Signatory]\\n[Employee Name] \\nBy: ________________________ [Employee Signature]\\nDate: ________________________\\nTop of Form\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0x41dda7be30130cebd867f439a759b9e7ab2569e9;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 10000; // Monthly salary amount in USDC\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1796774400; // Unix timestamp of Wed Dec 09 2026 00:00:00 GMT+0000 (Greenwich Mean Time)\n    uint256 public terminationDate = 2219439600; // Unix timestamp of Tue May 01 2040 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; \n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n        \n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary);\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    // Update performance threshold \n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\nFixed-Term Employment Contract\\nBetween Innovative Solutions Co. (Hereinafter referred to as \"Employer\")\\nAnd Michaela Johnson Address: 789 Willow Avenue, Parkside, ABC (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Marketing Manager. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on October 10, 2024, and shall terminate on October 9, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $85,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0xc6962004f452be9203591991d15f6b388e09e8d0. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0xc6962004f452be9203591991d15f6b388e09e8d0;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 7083; // Monthly salary amount in USDC\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1728514800; // Unix timestamp of Thu Oct 10 2024 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public terminationDate = 1759964400; // Unix timestamp of Thu Oct 09 2025 00:00:00 GMT+0100 (British Summer Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n        \n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary);\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\nFixed-Term Employment Contract\\nBetween Tech Solutions Innovate Ltd. (Hereinafter referred to as \"Employer\")\\nAnd Emily Davis Address: 123 Oak Street, Springfield, XYZ (Hereinafter referred to as \"Employee\")\\nPosition and Duties The Employer hereby employs the Employee on a full-time basis as a Software Developer. The Employee agrees to perform the duties and responsibilities as required by the Employer faithfully and to the best of their ability.\\nTerm of Employment The employment under this contract shall commence on November 15, 2024, and shall terminate on November 14, 2025, unless earlier terminated in accordance with this contract.\\nSalary The Employer agrees to pay the Employee a salary of $95,000 USD per annum, payable monthly in USDC tokens to the Employee's designated wallet address 0x09400d9db990d5ed3f35d7be61dfaeb900af03c9. Payment will be made no later than the 5th day of each month.\\nPerformance Review The Employee's performance will be reviewed annually, and salary adjustments may be made at the discretion of the Employer based on performance metrics.\\nTermination Either party may terminate this contract before the expiry of the term by providing a 30-day written notice. Upon termination, the Employee will be entitled to receive the salary accrued up until the termination date.\\nConfidentiality The Employee shall maintain confidentiality during and after the term of employment regarding all proprietary information of the Employer.\\nGoverning Law This contract shall be governed by the laws of the jurisdiction where the Employer is located.\\nIN WITNESS WHEREOF, the parties hereto have executed this contract as of the last date written below.\\nEmployer Signature: ___________________ Date: _______________\\nEmployee Signature: ___________________ Date: _______________\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0x09400d9db990d5ed3f35d7be61dfaeb900af03c9;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 7916; // Monthly salary amount in USDC ($95,000 USD per annum)\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1731628800; // Unix timestamp of Fri Nov 15 2024 00:00:00 GMT+0000 (Greenwich Mean Time)\n    uint256 public terminationDate = 1763078400; // Unix timestamp of \tFri Nov 14 2025 00:00:00 GMT+0000 (Greenwich Mean Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; // Performance score, updated by the authorized app\n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n        \n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary);\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\nEmployment Contract\\nThis Employment Contract (\"Contract\") is made and entered into on this [Start Date], by and between:\\nInnovative Solutions Group Address: 123 Innovation Street Techville, TV 54321\\nHereinafter referred to as the \"Company,\"\\nand\\nNatalie Evans Address: 456 Programmer's Lane Coder City, CC 67890\\nHereinafter referred to as the \"Employee.\"\\nThe Company, in consideration of the covenants and agreements herein contained, hereby employs Natalie Evans, and Natalie Evans hereby accepts employment under the following terms and conditions:\\nPosition and Duties: The Employee shall serve as a Software Engineer and shall perform such duties and responsibilities as may be reasonably assigned by the Company's management. The employee is employed on a full-time basis.\\nStart Date: The employment of Natalie Evans shall commence on 30.04.2042.\\nSalary: The Company agrees to pay Natalie Evans a monthly salary of $6,800 (USD), payable in accordance with the Company's standard payroll procedures. Payment to be made to employees USDC address: 0x0b2402144bb366a632d14b83f244d2e0e21bd39c.\\nBenefits: Natalie Evans shall be eligible to participate in the Company's employee benefit plans and programs, subject to the terms and conditions of such plans and programs as in effect from time to time.\\nWorking Hours: Natalie Evans's normal working hours shall be 40 hours per week, Monday through Friday, with one hour for lunch.\\nTermination: Either party may terminate this Contract at any time, with or without cause, by providing 30 days' written notice to the other party.\\nConfidentiality: Natalie Evans agrees to maintain the confidentiality of all proprietary and confidential information of the Company and its clients.\\nGoverning Law: This Contract shall be governed by and construed in accordance with the laws of the State of California.\\nEntire Agreement: This Contract constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior agreements, understandings, negotiations, and discussions, whether written or oral, between the parties relating to such subject matter.\\nIN WITNESS WHEREOF, the parties hereto have executed this Contract as of the date first above written.\\nInnovative Solutions Group\\nBy: [Authorized Signatory] Title: [Authorized Signatory Title] Date: _______________________\\nNatalie Evans\\nBy: _______________________ [Employee Signature] Date: _______________________\\nTop of Form\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0x0b2402144bb366a632d14b83f244d2e0e21bd39c;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salar = 6800; // Monthly salary amount in USDC\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1714445593; // Unix timestamp of Tue Apr 30 2024 03:53:13 GMT+0100 (British Summer Time)\n    uint256 public terminationDate = 5555555555; // Open ended contract with no termination date bein set up, hence we set it to a very distant point. Couldbe updated later on.\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; \n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'monthly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 30 days, \"Salary already paid for this month\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n\n        lastSalaryPaidDate += 30 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary);\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    // Update performance threshold \n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}
{"messages": [{"role": "system", "content": "Convert the following legal employment contract into a Solidity smart contract. You shall pass back only code!"}, {"role": "user", "content": "Legal contract:\n\nEMPLOYMENT CONTRACT\\nThis Employment Contract (the \"Contract\") is made effective as of February 15, 2024, by and between TechSolutions Inc., a corporation organized and existing under the laws of the State of California, with its principal office located at 789 Innovation Avenue, Tech City, CA 54321 (\"Company\"), and Sarah Johnson, (\"Employee\").\\nPOSITION AND DUTIES\\nThe Company hereby agrees to employ the Employee in the position of Senior Software Engineer. The Employee agrees to perform the duties and responsibilities assigned by the Company faithfully and to the best of their ability.\\nTERM OF EMPLOYMENT\\nThe term of employment shall commence on February 15, 2024, and shall terminate on February 15, 2026, unless otherwise terminated in accordance with the provisions of this Contract. The employee is employed on a full-time basis.\\nSALARY\\nThe Company shall pay the Employee a monthly salary of $7,500 USD on a weekly basis, payable in USDC to the Employee's wallet address as follows: 0xc657a1440d266dd21ec3c299a8b9098065f663bb. Payment shall be made on the last business day of each month.\\nCONFIDENTIALITY\\nThe Employee agrees to keep all proprietary information of the Company confidential and not to disclose it to any third parties during and after the term of their employment.\\nGOVERNING LAW\\nThis Contract shall be governed by and construed in accordance with the laws of the State of California.\\nIN WITNESS WHEREOF, the Parties have executed this Employment Contract as of the date first above written.\\nCOMPANY: By: John Doe Name: John Doe Title: CEO\\nEMPLOYEE: Signature: Sarah Johnson Name: Sarah Johnson\\n"}, {"role": "assistant", "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport \"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevent re-entrancy attacks\n\ncontract EmploymentContract is ReentrancyGuard {\n    address public employer;\n    address public employee = 0xc657a1440d266dd21ec3c299a8b9098065f663bb;\n    address private authorizedApp; // Address of the authorized app to update metrics\n    uint256 public salary = 7500; // Monthly salary amount in USDC\n    IERC20 private usdcToken; // USDC token contract interface\n    uint256 public startDate = 1707969193; // Unix timestamp of Thu Feb 15 2024 03:53:13 GMT+0000 (Greenwich Mean Time)\n    uint256 public terminationDate = 1771127593; // Unix timestamp of Sun Feb 15 2026 03:53:13 GMT+0000 (Greenwich Mean Time)\n    uint256 public lastSalaryPaidDate; // Tracks last salary payment date\n    uint256 public performanceScore = 0; // Performance score, updated by the authorized app\n    uint256 public performanceThreshold = 0; \n    bool public isEmployed = true; // Employment status\n    string public salaryType = 'weekly'; // How often a salary payment to be initiated\n    \n    event SalaryUpdated(uint256 newSalary);\n    event BonusPaid(uint256 bonusAmount);\n    event EmploymentTerminated(string message);\n    event DisputeResolved(string message);\n    event SalaryPaid(uint256 amount);\n    event PerformanceScoreUpdated(uint256 score);\n    event PerformanceThresholdUpdated(uint256 threshold);\n    event TerminationDateUpdated(uint256 newTerminationDate);\n\n    modifier onlyAuthorizedApp() {\n        require(msg.sender == authorizedApp, \"Caller is not the authorized app\");\n        _;\n    }\n\n    constructor(\n        address _authorizedApp,\n        address _usdcTokenAddress\n    ) {\n        employer = msg.sender; // The address deploying the contract is the employer\n        authorizedApp = _authorizedApp;\n        usdcToken = IERC20(_usdcTokenAddress);\n        lastSalaryPaidDate = startDate; // Initialize with start date\n    }\n\n    // Function to deposit USDC into the contract for salary payments\n    function depositSalaryFunds(uint256 _amount) external nonReentrant {\n        require(msg.sender == employer, \"Only the employer can deposit funds\");\n        usdcToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Function to automatically withdraw monthly salary funds from the employer\n    function monthlyFunding() external onlyAuthorizedApp nonReentrant {\n        uint256 amountNeeded = salary * 3; // Ensure buffer for 3 months\n        uint256 currentBalance = usdcToken.balanceOf(address(this));\n        uint256 shortfall = 0;\n\n        if (currentBalance < amountNeeded) {\n            shortfall = amountNeeded - currentBalance;\n            // Attempt to transfer the shortfall from the employer to the contract\n            usdcToken.transferFrom(employer, address(this), shortfall);\n        }\n    }\n\n    // Automatically pay salary on a monthly basis\n    function autoPaySalary() external onlyAuthorizedApp nonReentrant {\n        require(isEmployed, \"Employment has ended\");\n        require(block.timestamp >= lastSalaryPaidDate + 7 days, \"Salary already paid for this period\");\n        require(usdcToken.balanceOf(address(this)) >= salary, \"Insufficient funds in contract\");\n        require(performanceScore >= performanceThreshold, \"Performance score does not meet the required threshold. Employee is underperforming\");\n\n        lastSalaryPaidDate += 7 days; // Update last salary paid date to current month\n        usdcToken.transfer(employee, salary / 4.4); // Since there are 4.4 weeks in a months and the pay is bi-weekly\n        emit SalaryPaid(salary);\n    }\n\n    // Update performance score\n    function updatePerformanceScore(uint256 _newScore) external onlyAuthorizedApp {\n        performanceScore = _newScore;\n        emit PerformanceScoreUpdated(_newScore);\n    }\n\n    // Update performance threshold \n    function updatePerformanceThreshold(uint256 _threshold) external onlyAuthorizedApp {\n        performanceThreshold = _threshold;\n        emit PerformanceThresholdUpdated(_threshold);\n    }\n\n    // Extend employment termination date\n    function extendTerminationDate(uint256 _newTerminationDate) external onlyAuthorizedApp {\n        require(_newTerminationDate > terminationDate, \"New date must be after current termination date\");\n        terminationDate = _newTerminationDate;\n        emit TerminationDateUpdated(_newTerminationDate);\n    }\n\n    // Update salary\n    function updateSalary(uint256 _newSalary) external onlyAuthorizedApp {\n        salary = _newSalary;\n        emit SalaryUpdated(_newSalary);\n    }\n\n    // Pay bonus\n    function payBonus(uint256 _bonusAmount) external onlyAuthorizedApp nonReentrant {\n        require(usdcToken.balanceOf(address(this)) >= _bonusAmount, \"Insufficient funds in contract\");\n        usdcToken.transfer(employee, _bonusAmount);\n        emit BonusPaid(_bonusAmount);\n    }\n\n    // Terminate employment with mutual agreement or trigger dispute resolution if disagreement\n    function terminateEmployment(bool employeePermission, bool employerPermission, bool employerFault) external onlyAuthorizedApp {\n        if (employeePermission && employerPermission) {\n            // If both parties agree, terminate employment and notify\n            isEmployed = false;\n            emit EmploymentTerminated(\"Employment terminated by mutual agreement.\");\n        } else {\n            // If there is no mutual agreement, determine who does not agree and resolve the dispute\n            _resolveDispute(employerFault);\n        }\n    }\n\n    // Function to check contract balance (for employer's view)\n    function checkContractBalance() external view returns (uint256) {\n        return usdcToken.balanceOf(address(this));\n    }\n\n    // Additional function to handle disputes and protect the salary buffer\n    function _resolveDispute(bool employerFault) internal {\n        uint256 contractBalance = usdcToken.balanceOf(address(this));\n        address recipient = employerFault ? employee : employer;\n        usdcToken.transfer(recipient, contractBalance);\n\n        isEmployed = false;\n\n        string memory resolutionMessage = employerFault \n            ? \"Employer at fault, funds transferred to employee.\" \n            : \"Employee at fault, funds transferred to employer.\";\n        emit DisputeResolved(resolutionMessage);\n        emit EmploymentTerminated(\"Employment terminated due to dispute resolution.\");\n    }\n\n    // External interface for dispute resolution, callable by authorized app\n    function resolveDispute(bool employerFault) external onlyAuthorizedApp {\n        _resolveDispute(employerFault);\n    }\n}\n"}]}